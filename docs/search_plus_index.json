{"./":{"url":"./","title":"Introduction","keywords":"","body":" Zander's Notes Zander's Notes 欢迎来到我的学习笔记站点。 个人博客：xuezenghui.com Zander Hsueh            updated 2022-06-12 16:54:58 "},"Dev/":{"url":"Dev/","title":"Dev","keywords":"","body":" 开发 开发 Zander Hsueh            updated 2022-06-12 18:35:50 "},"Dev/MongoDB.html":{"url":"Dev/MongoDB.html","title":"Mongo DB","keywords":"","body":" MongoDB1. 主键2. 增2.1. 写入单个文档2.2. 写入多个文档3. 查3.1. 过滤数据3.2. 比较操作符3.3. 逻辑操作符3.4. 字段操作符3.5. 数组操作符3.6. 运算操作符3.7. 文档游标3.8. 分页函数3.9. 排序函数3.10. 统计函数4. 改4.1. 更新文档的方法4.2. 更新操作符5. 删6. 聚合操作6.1. $project6.2. $macth6.3. $limit 和 $skip6.4. $unwind6.5. $sort6.6. $lookup6.7. $group6.8. $out6.9. 聚合操作额外配置6.10. 聚合操作表达式6.11. 数据类型转换操作符7. 索引7.1. explain() 查询分析工具7.2. 复合索引7.3. 多键索引7.4. 索引对排序的影响7.5. 唯一索引7.6. 稀疏索引7.7. 索引生存时间7.8. 删除索引8. 数据模型8.1. 文档间关系9. Mongoose10. 复制集10.1. 复制集同步规则11. 分片11.1. 分片结构11.2. 分片片键11.3. 如何选择片键11.4. 分片查询 MongoDB 1. 主键 用于保证每一条数据的唯一性 自动添加，无需自行指定，主键名为 _id _id 是一个 ObjectId 类型的数据，即一个12个字节的字符串（4e5ade53-8cd45e-9de3-d943ae） 4子节是存储这条数据的时间戳 3字节是存储这条数据的电脑的标识符 2字节是存储这条数据的 MongoDB 进程 id 3字节是计数器 可保证数据库横向扩展后数据的唯一性。 2. 增 2.1. 写入单个文档 1. db..insertOne() 2. db..save() 两个方法的区别在于插入时如果主键重复，insertOne() 报错，插入失败，而 save() 会覆盖已存在的数据。 2.2. 写入多个文档 1.db..insertMany() 接收两个参数： 文档数组 可选的配置项对象，对象内可传入 ordered ，表示是否按顺序写入。默认为 true，前面的文档出错时后面的所有文档都不会被写入。设为 false 时，不按顺序写入，但写入效率较高，前面的文档出错，后面所有文档会被继续写入。 3. 查 3.1. 过滤数据 1. db..find(, ) query：查询的条件 projection：投影文档，规定查询的结果中显示哪些字段，默认都为1，不显示字段的设为 0 投影的条件不能同时包含 0 和 1（_id 不受限制），如不能为 db.getCollection('person').find({}, {age: 0, name: 1}); 3.2. 比较操作符 $eq：等于 $ne：不等于（不存在需要判断的字段也算作不等于） $gt：大于 $gte：大于等于 $lt：小于 $lte：小于等于 db..find({name: {$ne: \"Zander\"}}); $in：匹配和任意指定值相等的文档，值为数组 $nin：匹配和任意指定值都不相等的文档，值为数组（不存在需要判断的字段也满足条件） db..find({name: {$in: [\"Zander\", \"Paul\", \"Leon\"]}}); 3.3. 逻辑操作符 逻辑操作符后需为一个正则表达式或对象。 $not：非（不存在需要判断的字段也满足条件） $and：且 $or：或 $nor：都不（不存在需要判断的字段也满足条件） // 查询所有名字不为 Zander 的 db.person.find({name: {$not: {$eq: \"Zander\"}}}); // 且 db.person.find({$and: [{name: \"Zander\", age: 18}]}); // 或 db.person.find({$or: [{name: \"Zander\"}, {name: \"Hello\"}]}) // not or 都不 db.person.find({$nor: [{name: \"Zander\"}, {name: \"Hello\"}]}) 3.4. 字段操作符 $exists：查询包含某个字段的文档 可配合 $ne、$nin、$nor、$not 清理数据 db.person.find({name: {$ne: 'Zander', $exists: true}}) $type：查询指定字段包含指定类型的文档 db.person.find({age :{$type: 'number'}}) 3.5. 数组操作符 $all：匹配数组字段包含指定数组内所有元素的文档 db.getCollection('person').find({book: {$all: [\"a\", \"b\"]}}) $is：匹配数组字段中至少有一个元素符合多个查询条件的文档 db.getCollection('person').find({students: {$elemMatch: {name: \"Zander\", age: 18}}}) 3.6. 运算操作符 $regex：查询满足正则的文档 // 匹配 name 以 z/Z 开头的文档，i 表示忽略大小写 db.getCollection('person').find({name: {$regex: /^z/, $options: 'i'}}) // or db.getCollection('person').find({name: {$regex: /^z/i}}) 3.7. 文档游标 find() 方法的返回值是一个文档游标，相当于 C 语言的指针，文档游标的方法有： hasNext()：判断是否还有下一个文档 next()：取出下一个文档 forEach()：依次取出所有文档 3.8. 分页函数 cursor.limit()：取出文档的数量 cursor.skip()：跳过文档的数量 3.9. 排序函数 cursor.sort({field: ordering})：按照指定规则排序 ordering 为1表示升序，为-1表示降序 sort 和 limit/skip 同时使用时，无论 sort 写在前面还是后面都会先执行 sort。 3.10. 统计函数 count()：统计查询结果的数目 可接收一个 applySkipLimit 参数，表示统计数目时是否忽略 skip 和 limit，默认为 false，表示忽略 skip 和 limit 查询总数。 db.getCollection('person').find({}).limit(5).sort({age: 1}).count({applySkipLimit: true}) 4. 改 4.1. 更新文档的方法 1. db..save() 当没有指定 _id 字段时为新增，如果指定了已经存在的 _id 则覆盖原文档。 2. db..update(, , ) ：筛选条件 ：新的内容 ：配置项 默认会覆盖原文档，若要只更新，则需使用更新操作符。 默认只更新满足筛选条件的第一个文档，若要更新所有满足条件的文档需指定第三个参数 { multi: true}，同时在第二个参数中必须使用更新操作符 第二个参数中如果指定了 _id，则必须与原文档取值一致，否则报错无法更新（一般不指定 _id） 3. db..findAndModify() 4.2. 更新操作符 默认情况下 update 会直接覆盖旧文档，使用更新操作符可更新文档内特定的字段。 1. $set 更新或新增字段，字段存在则更新，不存在则新增。 db.getCollection('person').update({name: \"Tony\"}, {$set: {age: 99, book: \"her\"}}) 2. $unset 删除字段，字段的值无关紧要。 db.getCollection('person').update({name: \"Tony\"}, {$unset: {'age': \"\"}}) 如果删除的是数组字段中的元素，不会改变数组的长度，而是使用 null 替换删除的内容 3. $rename 重命名字段。 db.getCollection('person').update({name: \"Tony\"}, {$rename: {'name': \"first_name\"}}) 如果文档里已经存在新的名称，则会删除已经存在的字段 不能通过 $rename 来操作数组内对象的属性名 使用技巧： 可将内层文档中的字段转移到外层，或将外层转移到内层： db.getCollection('person').update({name: \"Tony\"}, {$rename: {'age': \"obj.age\"}}) 4. $inc 更新字段值（增加或减少字段的值），只能操作 Number 类型的字段。 db.getCollection('person').update({name: \"Tony\"}, {$inc: {'age': 2}}) db.getCollection('person').update({name: \"Tony\"}, {$inc: {'age': -5}}) 若不存在要操作的字段，则新增这个字段，初始值为0再执行增加/减少操作。 5. $mul 更新字段值（乘以或除以字段的值），只能操作 Number 类型的字段。 6. $min 更新值时保存较小的值。 db.getCollection('person').update({name: \"Zander\"}, {$min: {'age': 1}}) 如果要操作的字段不存在，则自动增加这个字段并将值赋给它。 6. $max 更新值时保存较大的值。 7. $addToSet 向数组字段中添加元素。 db.getCollection('person').update({name: \"Zander\"}, {$addToSet: {\"book\": \"金瓶梅\"}}) 如果要操作的字段不存在，则自动增加这个数组字段并向数组中添加元素。 添加的元素会自动去重。 8. $push 向数组字段中添加元素（不去重）。 9. $pop 从数组中删除元素，传1表示删除最后一个元素，传-1表示删除第一个元素。 db.getCollection('person').update({name: \"Zander\"}, {$pop: {\"book_name\": -1}}) 10. $pull 从数组中删除指定的元素，可以指定具体的值或正则表达式。 db.getCollection('person').update({name: \"Zander\"}, {$pull: {\"book_name\": \"123\"}}) // 指定元素的值 db.getCollection('person').update({name: \"Zander\"}, {$pull: {\"book_name\": /^1/}}) // 指定正则表达式 如果要删除的数组内的元素是 Object 类型，只要匹配到一个属性就可删除整个对象。 11. $pullAll 从数组中批量删除特定元素。 db.getCollection('person').update({name: \"Dom\"}, {$pullAll: {book: [\"三国\", \"西游\"]}}) 如果要删除的数组内的元素是 Array 类型或者 Object 类型，元素的顺序和值必须一摸一样才可删除。 12. $和$[] $：更新数组中满足条件的特定元素 db.getCollection('person').update({name: \"Dom\", \"book.name\": \"西游\"}, {$set: {\"book.$.name\": \"水浒\"}}) // 更新数组中对象的属性值 $[]：更新数组中所有元素 db.getCollection('person').update({name: \"Zander\"}, {$set: {\"book_name.$[]\": \"水浒\"}}) 5. 删 1. 删除所有满足条件的数据 db.getCollection('person').remove({name: \"Zander\"}) 2. 删除满足条件的第一条数据 db.getCollection('person').remove({name: \"Zander\"}, {justOne: true}) 6. 聚合操作 聚合操作就是通过一个方法完成一系列的方法，聚合中的每一个操作成为一个阶段，上一阶段会将处理的结果传给下一个阶段继续处理。 6.1. $project 作用：对输入的文档进行再次投影，按照需要的格式生成结果 格式：{$project: { field: value }} 如果在 $project 操作中使用了原文档中不存在的字段则自动添加，使用 null 填充。 db.getCollection('person').aggregate([ { $project: { _id: 0, my_name: \"$name\" } } ]) 6.2. $macth 作用：用于筛选符合条件的文档 格式：{$match:{ field: value }} 6.3. $limit 和 $skip 1. $limit 作用：用于指定获取的文档数目 格式：{$limit: } 2. $skip 作用：用于指定跳过的文档数目 格式：{$skip: } 6.4. $unwind 作用：展开数组字段 格式：$unwind: {path: } 参数： includeArrayIndex: 'index'：在结果中添加数组的索引 preserveNullAndEmptyArrays: true：空数组和 null 也拆分 6.5. $sort 作用：排序 格式：$sort: {} 6.6. $lookup 作用：关联查询 格式： 关联形式： {$lookup: { form: localField: foreignField: as: } } 不关联形式： {$lookup: { form: let: { 定义给关联集合的聚合操作使用的当前集合的常量 } pipeline: [关联集合中的聚合操作] as: } } 6.7. $group 作用：对文档进行分组 格式： {$group: { _id: , : { }, ...: ... } } 6.8. $out 作用：将前面阶段处理完的文档写入一个新的集合 格式：{$out: } 若不存在这个集合，则自动创建；若已存在这个集合，则直接覆盖。 6.9. 聚合操作额外配置 db..aggregate(, ) 1. allowDiskUse: 管道阶段占用内存超过100M时允许写入数据到临时文件中。 6.10. 聚合操作表达式 1. 字段路径表达式 $：使用 $ 表示字段路径 {$project: { _id: 0, name: '$name' } } 2. 系统变量表达式 $$CURRENT：表示当前操作的文档 $$CURRENT.name === $name 3. 常量表达式（相当于转义） $literal: {$project: { _id: 0, name: {$literal: '$name'} } } 6.11. 数据类型转换操作符 作用：将不同的数据类型转换为相同的类型，便于后续处理，不是一个单独的管道阶段 格式： {$convert: { input: , to: , onError: , onNull: } } 7. 索引 用于提升数据的查询速度，相当于字段的目录。 主键会默认创建索引 获取索引：getIndexes() 创建索引：createIndex({ : 1 | -1 })，1表示正序，-1倒序 7.1. explain() 查询分析工具 db.getCollection('person').find({name: \"Zander\"}).explain() 依据 winningPlan 中的 stage 的取值来判断查询的方式： IXSCAN：根据索引查询 COLLSCAN：遍历整个集合查询 7.2. 复合索引 db.getCollection('person').createIndex({name: -1, age: -1}) 查询的时候只支持前缀查询（查询条件包含前缀），如上面的查询只支持使用 name 的索引查询，使用 age 查询时不会使用索引。 7.3. 多键索引 为数组字段创建索引时会为其每一个元素都创建索引。 7.4. 索引对排序的影响 排序的字段若不是索引字段，会在执行查询的时候排序再输出；反之，直接获取索引对应的文档来输出。 如果是符合索引，则排序条件包含索引字段的前缀字段才会使用索引来排序 7.5. 唯一索引 主键默认为唯一索引 创建唯一索引：指定参数 {unique: true} 若添加的字段没有唯一索引的字段，第一个这样的文档会自动填充null，第二个会报错 7.6. 稀疏索引 稀疏索引可优化索引占用的存储空间，添加参数 {sparse: true}。 稀疏性索引忽略不含有索引字段的文档，即如果索引具备唯一性且具备稀疏性，可添加缺失索引字段的文档 7.7. 索引生存时间 若文档包含日期字段或包含日期的数组字段，可在创建索引的时候指定索引的生存时间，超过生存时间会自动删除对应的文档。 ⚠️不能保证即时性。 db.getCollection('person').createIndex({addTime: 1}, {expireAfterSeconds: 5}) 若给数组字段指定了超时时间，则以数组中时间最小的值为基准计算超时时间。 7.8. 删除索引 db..dropIndex() 8. 数据模型 8.1. 文档间关系 内嵌式结构 一次查询就能得到所有数据 若数据比较复杂，不方便管理和更新 适用于数据不复杂/查询频率较高的场景 规范式结构：通过 id 关联 方便管理复杂的数据 查询数据相对麻烦 适用于数据复杂/更新频率较高的场景 关系的方式： 一对一 一对多 多对多 9. Mongoose 安装并导入 链接 MongoDB 监听链接状态 // 自调用函数返回 Promise (async () => { const result = await User.find({}); })(); 10. 复制集 如果所有数据都存储在一台 MongoDB 服务器上： 不具备高可用性，一旦服务器宕机，用户无法继续使用 不具备数据安全性，服务器损坏数据丢失 不能对数据进行分流（访问数据时远慢近快） 将多台保存了相同内容的 MongoDB 服务器组成一个集群，称为复制集。 在复制集中每一台 MongoDB 服务器都是一个节点。 在一个复制集中最多有50个节点。 在复制集中必须有一个主节点，只有主节点可以同时读写数据，其它副节点只能读数据。 复制集中节点之间每隔2秒相互发送心跳请求，检查是否有节点出现问题，若某个节点10s没有相应请求，视为出现问题。 主节点若出现问题，副节点自动发起投票，重新选举主节点。 触发选举的条件： 初始化复制集时 有新节点加入时 已有主节点挂了时 10.1. 复制集同步规则 初始化同步 当有一个新节点加入到复制集之后，会将所有主节点的数据拷贝到新节点中 同步写库记录 在每一个 MongoDB 服务器上都有一个 local 数据库，其中 oplog 集合保存当前服务器的所有操作记录。执行完初始化同步后，副节点会定期同步和执行写库记录 11. 分片 分片就是将数据库集合中的数据拆分成多份，分布式地保存到多台主机上，可解决服务器的容量问题。 并不是所有集合都需要做分片，不使用分片的集合统一保存在主分片中。 11.1. 分片结构 分片服务器：同于存储不同数据的多个服务器 配置服务器：用于配置分片服务器存储范围 路由服务器：负责分发客户端请求 路由服务器分发请求的流程： 客户端发送请求到路由服务器 路由服务器配置服务器查询数据段（数据范围） 根据查询的结果到对应的分片服务器上做处理 拿到处理结果，将处理的结果返回给用户 11.2. 分片片键 分片片键用于将数据存储到不用的分片服务器上。 可以将文档里的一个或多个字段设置为分片片键 设置完后，mongodb 会自动按照字段的取值进行划分，划分为一个个数据段 然后 mongodb 会自动决定哪个分片服务器保存哪些数据段 注意点： 片键可以一个或者多个字段 只有索引字段才能被设置为片键 分片服务器保存哪些数据段的值是随机的，并不是连续的 数据段的划分可以使用片键的取值，也可以使用片键取值的哈希值 11.3. 如何选择片键 片键字段取值范围应更广，以划分更多的数据段 字段取值的分配应更平衡，而不是都集中在某个数据段内 不应该选择单向增加或者减少的字段作为片键 技巧： 取值不够广或不够平衡，可使用复合片键 如果取值是单向增加/减少，可使用其哈希值划分 片键一旦选择就不能更改，前期选择片键要谨慎。 11.4. 分片查询 查询的条件是分片片键 路由服务器可以准确找到保存对应数据的分片服务器。 查询的的条件不是分片片键 将请求发送到所有分片服务器上，再将返回的结果整合，整合后返回给客户端。 Zander Hsueh            updated 2022-06-12 18:35:50 "},"Dev/MySQL.html":{"url":"Dev/MySQL.html","title":"My SQL","keywords":"","body":" MySQL1. SQL语句1.1. 数据库操作1.2. 表操作1.3. 存储引擎1.4. 数据操作2. 数据类型2.1. 整数类型2.2. 浮点类型2.3. 定点类型2.4. 字符类型2.5. 大文本类型2.6. 枚举类型2.7. 集合类型2.8. 布尔类型2.9. 日期类型3. 数据完整性3.1. 实体完整性3.2. 域完整性3.3. 参照完整性4. 查询深入5. 事务 MySQL 1. SQL语句 功能划分： DDL：数据定义语句，用来定义数据库对象，创建库、表、列等 DML：数据操作语句，操作数据库表中的记录 DQL：数据库查询语句 DCL：数据控制语句，用来定义访问权限和安全级别 1.1. 数据库操作 创建数据库 create database 名称; 名称若是关键字或特殊符号，需要添加``符号。 无则创建，有则跳过： create database if not exists 名称; 指定编码格式： create database if not exists 名称 charset=utf8; 查看数据库全局默认编码： show variables like 'character_set_%'; 查看指定数据库编码格式： show create database 库名; 删除数据库 drop database 名称; 有则删除，无则跳过： drop database if exists 名称; 修改数据库 修改字符集： alter database 名称 charset=utf8; 1.2. 表操作 对数据库的表操作前需指定要操作的数据库： use 库名; 创建表 create table if not exists 表名( field名称 数据类型, field名称 数据类型 ); 查看所有表： show tables; 查看表结构： desc 表名; 删除表 drop if exists 表名; 修改表 修改表名： rename table 原表名 to 新表名; 添加字段： alter table 表名 add 字段名称 数据类型 [位置]; 位置参数：可选，默认会新增到最后，可指定为 first、after 已有字段名。 删除字段： alter table 表名 drop 字段名; 修改字段： // 只修改字段类型 alter table 表名 modify 字段名 数据类型; // 修改字段名及数据类型 alter table 表名 change 原字段名 新字段名 数据类型; 1.3. 存储引擎 不同存储引擎的安全级别、存储功能等不一样： MyISAM：安全性低，不支持事务和外键。适合频繁插入和查询而不修改的场景 InnoDB（默认）：安全性高，支持事务和外键，适合对安全性、数据完整性要求较高的应用 Memory：访问速度极快，但不会永久存储数据，适合对读写速度要求较高的应用 修改表的存储引擎： alter table 表名 engine=Memory 1.4. 数据操作 插入数据 insert into 表名 (field1, field2) values (value1, value2); 查询数据 查询表中所有数据： select * from 表名; 条件查询： select field1, field2 from 表名 [where 条件]; where支持的运算符： = != IN(set)：值包含 BETWEEN...AND：值的范围 IS NULL IN NO NULL AND OR NOT 更新数据 update 表名 set 字段名=值 [where 条件]; 不指定条件则修改表内所有数据的值。 删除数据 delete from 表名 [where 条件]; 2. 数据类型 2.1. 整数类型 类型 解释 字节 取值范围 TINYINT 小整数值 1 (-128, 127)或无符号范围(0, 255) SMALLINT 大整数值 2 (-32768, 32767) MEDIUMINT 大整数值 3 (-8388608, 8388607) INT或INTEGER 大整数值 4 (-2147483648, 2147483647) BIGINT 任意大 8 设置无符号整型： id int unsigned; 整型可设置位宽，长度不足补零： create table person ( id int(2) zerofill ) 2.2. 浮点类型 FLOAT(m, d)：4字节，单精度 DOUBLE(m, d)：8字节，双精度 区别： 占用存储空间大小不同 默认保留小数位数不同 保留的小数有效精度不同 2.3. 定点类型 decimal(m, d)：也用于存储小数，本质是将数据分为两个部分存储，每个部分都是整数，非常消耗资源。 2.4. 字符类型 CHAR(size)：0-255字节，定长字符串 varchar(size)：：0-65535字节，变长字符串 区别： 能够保存的数据容量不同 char 不会回收多余的字符，设置长度多大就多大，varchar 会回收多余字符 varchar 理论可以存储 65535 个字符，但实际会随着当前数据库的字符集改变，如utf-8为 65535/3=21845字符。gbk 32767个字符。 2.5. 大文本类型 MySQL 中对每一行数据的大小有限制，每行最多 65534 字节。 TINYTEXT：0-255字节，短文本字符串 TEXT：0-65535字节，长文本数据 MEDIUMTEXT：0-16777215字节，中等长度文本数据 LONGTEXT：0-4294967295字节，极大文本数据 大文本类型在表中不会实际占用保存的字节数，而是利用10字节引用了实际保存数据的地址。 2.6. 枚举类型 ENUM(值1, 值2, ...) MySQL 中的枚举是通过整型实现的，并且从1开始。 2.7. 集合类型 SET(值1, 值2)：字段取值只能是几个固定值中的几个 集合类型通过 2^n 的整型实现的 2.8. 布尔类型 布尔类型也通过整型实现，0为假，1为真，原因是 MySQL 底层是用 C/C++ 实现的，非零即真。 2.9. 日期类型 类型 解释 字节 格式 DATE 日期 3 YYYY-MM-DD TIME 时间值或持续时间 3 HH:MM:SS DATETIME 混合日期和时间值 8 YYYY-MM-DD HH:MM:SS 存储时值要加引号。 3. 数据完整性 数据完整性指保证保存到数据库中的数据都是正确的，通过创建表时给表添加约束实现，分为三类： 实体完整性 域完整性 参照完整性 3.1. 实体完整性 表中的一行数据就是一个实体（entity），需保证每一行数据的唯一性。 约束类型： 主键约束 primary key 唯一标识每一条数据。 // 方式一 create table user( id int primary key, user_name varchar(5) ) // 方式二 create table user( id int, user_name varchar(5), primary key(id) ) 主键字段取值不可重复 主键字段不能为 NULL 一张表中只能有一个主键 联合主键：同时将多个字段作为一个主键。 create table user( id int primary key, user_name varchar(5), primary key(id, user_name) ) 唯一约束 unique 和主键的异同： 都能保证字段的取值不重复 主键在一张表中只能有一个，唯一约束不限制 设置唯一约束的字段可以为 NULL 自动增长列 auto_increment create table person( id int auto_increment primary key, name varchar(20) ) 自动增长的字段可以为 NULL，存储后会自动增加。 修改约束 1. 修改主键 alter table 表名 add primary key(字段); 2. 修改唯一约束 alter table 表名 add unique(字段); 3. 修改自动增长列 // 必须是主键才能修改 alter table 表名 modify 字段名 数据类型 auto_increment; 3.2. 域完整性 一行数据中的每个单元格都是一个域，即每一个字段 域的完整性指保证单元格数据的正确性 使用正确的数据类型 非空约束（not null） 默认约束（default） 3.3. 参照完整性 参照完整性又称引用完整性，用于保证多表之间引用关系的正确性。 表与表的关系： 一对一：不需要拆分 一对多：需要拆分，一个表存外键 多对多：需要拆分，添加关系表 外键：如果一张表中有一个字段指向了另一张表的主键，该字段为外键， create table grade( id int auto_increment primary key, uid int, foreign key(外键名字) references 主表名(主表主键名) ) 只有 InnoDB 的存储引擎才支持外键约束 外键的数据类型必须与指向的主键一致 一对多的关系中，外键一般定义在多的一方 定义外键的表称为从表，被外键引用的表称为主表 外键其它操作 动态添加外键： alter table 从表名称 add foreign key(外键字段名称) references 主表名称(主表主键名称); 查看外键： show create table 从表名称; 删除外键： alter table 从表名 drop foreign key 外键名; 外键操作有三个模式： 严格操作： 主表不存在对应数据，从表不允许条件 从表引用着数据，主表不允许删除和修改主键 指控操作 级联操作：自动更新 4. 查询深入 去重 select distinct 字段名 from 表名; 排序 select * from 表名 order by 排序依据1 asc/desc, 排序依据2 asc/desc; asc 升序 desc降序 模糊查找 select * from 表名 where 字段 like 值; 值中使用%作为通配符，如薛%。 跳过 select * from 表名 limit 0, 3; // 前三条数据 函数 select max(表名.字段名) form 表名; min() sum() avg()：求平均值 集合 查询在集合中的： select * from 表名 where 字段名 in (值1, 值2, 值3); 不在集合内：not in 查询在范围内的： select * from 表名 where 字段名 between 起始值 and 结束值; // 左右都包含 联查 旧语法： select * from 表1, 表2 where 表1.id = 表2._id; 新语法 join： select * from 表1 join 表2 on 表1.id = 表2._id; 以上联查方式如果一方没有数据则整个数据都会被过滤掉（与 MongoDB 的 aggregate 关联类似），若不需要整个过滤，使用 left join（更常用） 和 right join。 分组 select 分组依据字段, avg(字段2) from 表名 group by 分组依据字段 having 过滤条件; group by 必须结合函数使用。 having 只能与 group by 结合使用来过滤，指定计算结果的别名来操作过滤条件。 case when 当……则…… SELECT s.NAME, c.score, CASE WHEN c.score > 90 THEN \"牛逼\" WHEN c.score BETWEEN 60 AND 90 THEN \"麻麻得\" ELSE \"笨逼\" END FROM student s JOIN score c ON s.id = c.student_id; 5. 事务 银行转账例子，如果后面有一步操作失败，整个数据应该回滚至全部操作之前。 start transaction ...数据库操作 commit; 事务隔离的四个级别： read uncommitted：读取未提交的内容（最低的事务隔离级别） read committed：读取提交的内容（不可重复读取，重复读取可能结果不同，别的事务可能 commit 了） reaptable read：默认机制，可重复读（读取的结果相同，MVVC多版本并发控制机制解决了插入导致的幻影行读取问题） serializable：序列化（不允许事务并发，严重限制性能） Zander Hsueh            updated 2022-06-12 19:33:04 "},"Dev/Promise.html":{"url":"Dev/Promise.html","title":"Promise","keywords":"","body":" Promise 进阶1. JS 中的 error 处理1.1. 错误的类型1.2. 错误处理1.3. 错误对象2. Promise 的理解和使用2.1. Promise 是什么2.2. Promise 的状态改变2.3. Promise 的基本流程3. 为什么要用 Promise4. 语法5. 几个关键问题6. 自定义 Promise6.1. 构造函数版6.2. Class 版6.3. 宏队列与微队列7. 练习 Promise 进阶 1. JS 中的 error 处理 1.1. 错误的类型 Error：所有错误的父类型 ReferenceError：引用的变量不存在 console.log(a) TypeError：数据类型不正确 const a = null; a.forEach(i => { console.log(i); }) RangeError：数据值不在其所允许的范围内 function name() { name(); } name(); SyntaxError：语法错误 aaa a = 7; 1.2. 错误处理 捕获错误：try...catch 不捕获 error，下面的代码不会执行。 抛出错误：throw error function name() { if (Date.now()&2 === 1) { console.log('奇数'); } else { throw new Error('是偶数'); } } try { name(); } catch (error) { console.log(error.message); } 1.3. 错误对象 message 属性：错误相关信息 stack 属性：函数调用栈记录信息 2. Promise 的理解和使用 2.1. Promise 是什么 抽象表达： Promise 是 JS 中进行异步编程的新的解决方案（旧的是纯回调方式） 具体表达： 从语法上来说：Promise 是一个构造函数 从功能上来说：Promise 对象用来封装一个异步操作并可以获取其结果 2.2. Promise 的状态改变 pending 变为 resolved pending 变为 rejected 只有这两种状态，且一个 Promise 对象只能改变一次。无论成功还是失败，都会有一个结果数据，成功为 value，失败为 reason。 2.3. Promise 的基本流程 graph LR; A[new Promise 状态为pending]-->B{执行异步操作}; B-->|成功了执行resolve|C[Promise 对象resolved状态]; B-->|成功了执行reject|D[Promise 对象rejected状态]; C-->|通过then处理|E[回调onResolved方法]; D-->|通过then/catch处理|F[回调onRejected方法]; E-->G[新的Promise对象]; F-->G; // 1. 创建一个 Promise 对象 const p = new Promise((resolve, reject) => { // 执行器函数 // 2. 执行异步操作任务 setTimeout(() => { const time = Date.now(); if (time%2 == 0) { resolve('成功的数据' + time) } else { reject('失败的数据' + time) } }, 1000); // 3.1 如果成功了，调用 resolve // 3.2 如果失败了，调用 reject }) p.then( value => { // 接受得到成功的value数据 onResolved console.log('成功的数据', value); }, reason => { // 接受得到失败的reason数据 onRejected console.log('失败的数据', reason); } ) 3. 为什么要用 Promise 1. 指定回调函数的方式更加灵活 旧的智能在启动异步任务前指定 promise：启动异步任务 ➡️ 返回Promise 对象 ➡️ 给 promise 对象绑定回调函数 2. 支持链式调用，可解决回调地域问题 promise 链式调用 async/await 4. 语法 1. Promise 构造函数 Promise (excutor) {} excutor 函数：同步执行，(resolve, reject) => {} resolve 函数：内部定义成功时调用的函数，value => {} reject 函数：内部定义失败时调用的函数，reason => {} 2. Promise.prototype.then() (onPresolved, onRejected) => {} onResolved 函数：成功的回调函数 value => {} onRejected 函数：失败的回调函数 reason => {} 3. Promise.prototype.catch() 相当于 .then 的语法糖： then(undefined, onRejected) 4. Promise.resolve() 语法糖，产生一个成功的 promise。 const p = Promise.resolve(1); p.then(value => { console.log(value) }); // 输出 1 value：成功的数据或 Promise 对象 5. Promise.reject() 语法糖，产生一个失败的 promise。 (reason) => {} reason：失败的原因 6. Promise.all() (promises) => {} promises：包含n个promise的数组 返回一个新的 promise，只有所有的 promise 都成功才成功，一个失败则直接失败 7. Promise.race() (promises) => {} 返回一个新的 promise，第一个完成的promise结果状态就是最终的结果状态 5. 几个关键问题 1. 一个 promise 指定多个成功/失败的回调函数，都会调用吗？ 当 promise 改变为对应的状态都会调用 2. 改变 promise 状态和指定回调函数谁先谁后？ 都有可能，正常情况下是限制低估回调再改变状态，但也可以先改状态再指定回调 如何先改状态再指定回调？ 在执行器中直接调用 resolve() / reject() 延迟更长时间才调用 then(） 什么时候才能得到数据？ 如果先指定回调，则当状态发生改变时，回调函数就会被调用，得到数据 如果先改状态，则当指定回调的时候，回调函数就会调用，得到数据 3. promise.then() 返回的新 promise 的结果状态由什么决定？ 由 then() 指定的回调函数执行的结果决定 如果抛出异常，新 promise 的状态为 rejected，reason 为抛出的异常 如果返回的是非promise 的值，新 promise 的状态为 resolved，value 为返回的值 如果返回的是另一个新的 promise，这个 promise 的结果就会成为新 promise 的结果 new Promise((resolve, reject) => { // resolve(1) reject(1) }).then( value => { console.log('onResolved1', value); return 2; }, reason => { console.log('onRejected1', reason); return Promise.resolve(3); } ).then( value => { console.log('onResolved2', value); }, reason => { console.log('onRejected2', reason); } ) 4. Promise 如何串联多个操作任务？ promise 的 then() 返回一个新的 Promise 通过 then 的链式调用串联多个同步/异步任务 5. Promise 异常传透指的是？ 当使用 Promise 的 then() 链式调用时，可以在最后指定失败的回调 全段任何操作出了异常，都会传到最后失败的回调中处理 6. 如何中断 Promise 链，不再调用后面的回调函数？ 在回调函数中返回一个 pendding 状态的 promise 对象。 new Promise((resolve, reject) => { reject(1) }).then( value => { console.log('onResolved1', value); return 2; }, reason => { console.log('onRejected1', reason); return Promise.reject(222); } ).catch(reason => { console.log('catch', reason); return new Promise(() => {}); // pending 状态的 Promise 对象 }).then( value => { console.log('onResolved2', value); }, reason => { console.log('onRejected2', reason); } ) 6. 自定义 Promise 6.1. 构造函数版 /* 自定义 Promise 函数模块: IIFE */ (function (window) { /* Promise 构造函数 excutor 执行器函数（同步执行） */ const PENDING = 'pending'; const RESOLVED = 'resolved'; const REJECTED = 'rejected'; function MyPromise(excutor) { const that = this; that.status = PENDING; // 给 Promise 的对象指定 status 属性，初始值为 pending that.data = undefined; // 给 Promise 对象指定一个用于存储结果数据的属性 that.callbacks = []; // 每个元素的结构： { onResolved() {}, onRejected(){} } function resolve(value) { // 如果当前状态不是 pending，直接结束 if (that.status !== PENDING) { return; } // 将状态改为 resolved that.status = RESOLVED; // 保存 value 数据 that.data = value; // 如果有待执行的 callback 函数，立即异步执行回调函数 onResolved if (that.callbacks.length > 0) { setTimeout(() => { // 放入队列中执行所有成功的回调 that.callbacks.forEach(callbacksObj => { callbacksObj.onResolved(value); }) }); } } function reject(reason) { // 将状态改为 rejected that.status = REJECTED; // 保存 reason 数据 that.data = reason; // 如果有待执行的 callback 函数，立即异步执行回调函数 onRejected if (that.callbacks.length > 0) { setTimeout(() => { // 放入队列中执行所有成功的回调 that.callbacks.forEach(callbacksObj => { callbacksObj.onRejected(reason); }) }); } } // 立即同步执行 excutor try { excutor(resolve, reject) } catch (error) { // 如果执行器抛出异常，promise 对象变为 reject 状态 reject(error); } } /* Promise 原型对象的 then() */ MyPromise.prototype.then = function (onResolved, onRejected) { // 指定默认的失败的回调，实现异常传透 onResolved = typeof onResolved === 'function' ? onResolved : value => value; // 向后传递成功的 value onRejetced = typeof onRejected === 'function' ? onRejected : reason => { throw reason }; // 向后传递失败的 reason const that = this; // 返回一个新的 Promise 对象 return new MyPromise((resolve, reject) => { // 调用指定的回调函数处理 function handle(callback) { try { const result = callback(that.data); if (result instanceof MyPromise) { // 3. 如果回调函数执行返回的是 promise，return 的 promise 结果就是这个 promise的结果 result.then( value => resolve(value), // 当 result 成功时，return 的 promise 也成功 reason => reject(reason) // 当 result 失败时，return 的 promise 也失败 ) } else { // 2. 如果回调函数执行返回的不是 promise，return 的 promise 就会成功，value 为返回的值 resolve(result); } } catch (error) { // 1. 如果抛出异常，return 的 promise 就会失败，reason 为 error reject(error); } } if (that.status === PENDING) { // 当前状态还是 pending 状态，将回调函数保存起来 that.callbacks.push({ onResolved(value){ handle(onResolved); }, onRejected(reason){ handle(onRejected); } }); } else if(that.status === RESOLVED){ // 如果当前是 resolved 状态，异步执行 onResolved 并改变 retuen 的 promise 状态 setTimeout(() => { handle(onResolved); }); } else { // status === 'rejected' setTimeout(() => { handle(onRejected); }); } }); } /* Promise 原型对象的 catch() */ MyPromise.prototype.catch = function (onRejected) { return this.then(undefined, onRejected); } /* Promise 函数对象的 resolve 方法 */ MyPromise.resolve = function (value) { return new MyPromise((resolve, reject) => { if (value instanceof MyPromise) { // value 的结果作为promise 的结果 value.then(resolve, reject); } else { // value 不是 promise，promise成功，数据为 value resolve(value); } }); } /* Promise 函数对象的 reject 方法 */ MyPromise.reject = function (reason) { return new MyPromise((resolve, reject) => { reject(reason); }); } // Promise 函数对象的 all 方法 MyPromise.all = function (promises) { const values = new Array(promises.length); //用来保存所有成功value 的数组 let resolveCount = 0; // 保存成功 promise 的数量 return new MyPromise((resolve, reject) => { // 遍历获取每个 promise 的结果 promises.forEach((p, index) => { MyPromise.resolve(p).then( value => { // p成功，将成功的 value 存入values values[index] = value; resolveCount++; // 如果全部成功，将return 的promise变为成功 if (resolveCount === promises.length) { resolve(values); } }, reason => { // 只要一个失败了，retuen 的promise就失败 reject(reason); } ) }) }) } // Promise 函数对象的 race 方法 MyPromise.race = function (promises) { return new MyPromise((resolve, reject) => { // 遍历获取每个 promise 的结果 promises.forEach(p => { MyPromise.resolve(p).then( value => { // 一旦有成功了，return 成功 resolve(value); }, reason => { // 一旦有成功了，return 成功 reject(reason); } ) }) }) } // 返回一个 promise 对象，在指定的时间后才确定结果 MyPromise.resolveDelay = function (value, time) { return new MyPromise((resolve, reject) => { setTimeout(() => { if (value instanceof MyPromise) { value.then(resolve, reject); } else { resolve(value); } }, time); }); } // 返回一个 promise 对象，在指定的时间后才失败 MyPromise.rejectDelay = function (reason, time) { return new MyPromise((resolve, reject) => { setTimeout(() => { reject(reason); }, time); }); } // 向外暴露 Promise 函数 window.MyPromise = MyPromise; })(window) 6.2. Class 版 /* 自定义 Promise 函数模块: IIFE */ (function (window) { const PENDING = 'pending'; const RESOLVED = 'resolved'; const REJECTED = 'rejected'; class MyPromise { /* Promise 构造函数 excutor 执行器函数（同步执行） */ constructor(excutor) { const that = this; that.status = PENDING; // 给 Promise 的对象指定 status 属性，初始值为 pending that.data = undefined; // 给 Promise 对象指定一个用于存储结果数据的属性 that.callbacks = []; // 每个元素的结构： { onResolved() {}, onRejected(){} } function resolve(value) { // 如果当前状态不是 pending，直接结束 if (that.status !== PENDING) { return; } // 将状态改为 resolved that.status = RESOLVED; // 保存 value 数据 that.data = value; // 如果有待执行的 callback 函数，立即异步执行回调函数 onResolved if (that.callbacks.length > 0) { setTimeout(() => { // 放入队列中执行所有成功的回调 that.callbacks.forEach(callbacksObj => { callbacksObj.onResolved(value); }) }); } } function reject(reason) { // 将状态改为 rejected that.status = REJECTED; // 保存 reason 数据 that.data = reason; // 如果有待执行的 callback 函数，立即异步执行回调函数 onRejected if (that.callbacks.length > 0) { setTimeout(() => { // 放入队列中执行所有成功的回调 that.callbacks.forEach(callbacksObj => { callbacksObj.onRejected(reason); }) }); } } // 立即同步执行 excutor try { excutor(resolve, reject) } catch (error) { // 如果执行器抛出异常，promise 对象变为 reject 状态 reject(error); } } /* Promise 原型对象的 then() */ then(onResolved, onRejected) { // 指定默认的失败的回调，实现异常传透 onResolved = typeof onResolved === 'function' ? onResolved : value => value; // 向后传递成功的 value onRejected = typeof onRejected === 'function' ? onRejected : reason => { throw reason }; // 向后传递失败的 reason const that = this; // 返回一个新的 Promise 对象 return new MyPromise((resolve, reject) => { // 调用指定的回调函数处理 function handle(callback) { try { const result = callback(that.data); if (result instanceof MyPromise) { // 3. 如果回调函数执行返回的是 promise，return 的 promise 结果就是这个 promise的结果 result.then( value => resolve(value), // 当 result 成功时，return 的 promise 也成功 reason => reject(reason) // 当 result 失败时，return 的 promise 也失败 ) } else { // 2. 如果回调函数执行返回的不是 promise，return 的 promise 就会成功，value 为返回的值 resolve(result); } } catch (error) { // 1. 如果抛出异常，return 的 promise 就会失败，reason 为 error reject(error); } } if (that.status === PENDING) { // 当前状态还是 pending 状态，将回调函数保存起来 that.callbacks.push({ onResolved(value) { handle(onResolved); }, onRejected(reason) { handle(onRejected); } }); } else if (that.status === RESOLVED) { // 如果当前是 resolved 状态，异步执行 onResolved 并改变 retuen 的 promise 状态 setTimeout(() => { handle(onResolved); }); } else { // status === 'rejected' setTimeout(() => { handle(onRejected); }); } }); } /* Promise 原型对象的 catch() */ catch(onRejected) { return this.then(undefined, onRejected); } /* Promise 函数对象的 resolve 方法 */ static resolve = function (value) { return new MyPromise((resolve, reject) => { if (value instanceof MyPromise) { // value 的结果作为promise 的结果 value.then(resolve, reject); } else { // value 不是 promise，promise成功，数据为 value resolve(value); } }); } /* Promise 函数对象的 reject 方法 */ static reject = function (reason) { return new MyPromise((resolve, reject) => { reject(reason); }); } // Promise 函数对象的 all 方法 static all(promises) { const values = new Array(promises.length); //用来保存所有成功value 的数组 let resolveCount = 0; // 保存成功 promise 的数量 return new MyPromise((resolve, reject) => { // 遍历获取每个 promise 的结果 promises.forEach((p, index) => { MyPromise.resolve(p).then( value => { // p成功，将成功的 value 存入values values[index] = value; resolveCount++; // 如果全部成功，将return 的promise变为成功 if (resolveCount === promises.length) { resolve(values); } }, reason => { // 只要一个失败了，retuen 的promise就失败 reject(reason); } ) }) }) } // Promise 函数对象的 race 方法 static race(promises) { return new MyPromise((resolve, reject) => { // 遍历获取每个 promise 的结果 promises.forEach(p => { MyPromise.resolve(p).then( value => { // 一旦有成功了，return 成功 resolve(value); }, reason => { // 一旦有成功了，return 成功 reject(reason); } ) }) }) } // 返回一个 promise 对象，在指定的时间后才确定结果 static resolveDelay(value, time) { return new MyPromise((resolve, reject) => { setTimeout(() => { if (value instanceof MyPromise) { value.then(resolve, reject); } else { resolve(value); } }, time); }); } // 返回一个 promise 对象，在指定的时间后才失败 static rejectDelay(reason, time) { return new MyPromise((resolve, reject) => { setTimeout(() => { reject(reason); }, time); }); } } // 向外暴露 Promise 函数 window.MyPromise = MyPromise; })(window) 6.3. 宏队列与微队列 JS 中用来存储执行回调函数的队列包含 2 个不同的特定队列 宏队列：用来保存待执行的宏任务（回调），比如：定时器回调、DOM 事件回调、AJAX 回调 微队列： 用来保存待执行的微任务（回调），比如：Promise 的回调、MutationObserver 回调 JS 执行时会区别这两个队列 首先必须执行所有的初始化同步任务代码 每次准备取出第一个宏任务执行之前，都要将所有的微任务一个一个取出来执行 7. 练习 setTimeout(() => { // 放入宏队列，执行完同步任务后准备取出，但需要把所有微任务执行完 console.log(1); }, 0); Promise.resolve().then(() => { // 放入微任务队列 console.log(2); }) Promise.resolve(1).then(() => { // 放入微任务队列 console.log(4); }) console.log(3); // 先执行同步任务 // 3 2 4 1 setTimeout(() => { // 宏任务 console.log(1); }, 0); new Promise((resolve) => { console.log(2); // 同步任务1 resolve(); }).then(() => { console.log(3); // 微任务1 }).then(() => { console.log(4); // 微任务2 }) console.log(5); // 同步任务2 // 2 5 3 4 1 const first = () => (new Promise((resolve, reject) => { console.log(3); // 同步任务1 let p = new Promise((resolve, reject) => { console.log(7); // 同步任务2 setTimeout(() => { console.log(5); resolve(6); }, 0); resolve(1); }) resolve(2); p.then((arg) => { console.log(arg); }) })) first().then((arg) => { console.log(arg); }) console.log(4); // 同步任务3 // 宏 [5] // 微 [1 2] // 3 7 4 1 2 5 setTimeout(() => { console.log(0); }, 0); new Promise((resolve, reject) => { console.log(1); resolve(); }).then(() => { console.log(2); new Promise((resolve, reject) => { console.log(3); resolve() }).then(() => { console.log(4); }).then(() => { console.log(5); // 4 没有执行不能执行5，即5不能跟在4后放在微任务队列 }) }).then(() => { console.log(6); }) new Promise((resolve, reject) => { console.log(7); resolve(); }).then(() => { console.log(8); }) // 同步：1 7 // 宏：[0 ] // 微：[2 8 4 6 5] // 1 7 2 3 8 4 6 5 0 Zander Hsueh            updated 2022-06-12 19:35:17 "},"Dev/rem布局.html":{"url":"Dev/rem布局.html","title":"rem布局","keywords":"","body":" rem 自适应布局1. rem 基础1.1. 概念1.2. em 与 rem1.3. rem 的优点2. 媒体查询2.1. 概念2.2. 语法规范2.3. 案例——根据屏幕宽度修改背景颜色2.4. 案例——媒体查询 + rem 实现元素动态大小变化2.5. 引入资源3. Less 基础3.1. CSS 的弊端3.2. Less 介绍3.3. 安装 Less3.4. Less 变量3.5. rem 适配方案3.6. 适配方案一3.7. 适配方案二 rem 自适应布局 为什么要使用 rem 布局： 页面布局文字能否随着屏幕大小变化而变化？ 六十布局和 flex 布局主要针对于宽度布局，那高度如何设置？ 怎么样让屏幕发生变化的时候元素高度和宽度等比例缩放？ 1. rem 基础 1.1. 概念 rem （root em）是一个相对单位，类似于 em，em 相对于父元素的字体大小。 不同的是 rem 的基准是相对于 html 元素的字体大小。 1.2. em 与 rem em: Zander div { font-size: 12px; } p { /* 宽和高都是 12px *10 = 120px */ width: 10em; height: 10em; background-color: pink; } rem: html { font-size: 14px; } p { /* 宽和高都是 14px *10 = 140px */ width: 10rem; height: 10rem; background-color: pink; } 1.3. rem 的优点 rem 相对于根元素 html 的文字大小来控制， 便于控制页面中所有使用 rem 单位的元素。——整体控制 2. 媒体查询 2.1. 概念 媒体查询 Midea Query 是 CSS3 新语法，有以下特性： 使用 @media 查询，可以针对不同的媒体类型定义不同的样式 @media 可以针对不同的屏幕尺寸设置不用的样式 当重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面 目前针对很多苹果手机、安卓手机、平板等设备都用得到媒体查询 2.2. 语法规范 @media mediatype and|not|only (media feature) { css-code; } 用 @media 开头 mediatype 指媒体类型，如手机屏幕 关键字 and、not、only media feature 媒体特性，必须有小括号 1. mediatype 媒体类型 将不同的终端设备划分成不同的类型，称为媒体类型。 值 说明 all 用于所有设备 print 用于打印机和打印预览 scree 用于电脑设备、平板电脑、智能手机等 2. 关键字 关键字将媒体类型或多个媒体特性连接到一起作为媒体查询的条件。 and：将多个媒体特性连接到一起，相当于“且” not：排除某个媒体类型，相当于“非” only：指定某个特性的媒体类型 3. 媒体特性 每种媒体类型都具有各自不同的特性，根据不同媒体类型的媒体特性设置不同的展示风格。 值 说明 width 定义输出设备中页面可见区域的宽度 min-width 定义输出设备中最小可见区域宽度 max-width 定义输出设备中最大可见区域宽度 /* 在屏幕上并且最大的宽度是800px时（小于等于800px时）设置的样式 */ @media screen and (max-width: 800px) { body { background-color: pink; } @media screen and (max-width: 500px) { body { background-color: yellow; } } 2.3. 案例——根据屏幕宽度修改背景颜色 /* 1. 媒体查询一般按照从大到小或者从小到大的顺序来设置 */ /* 2. 小于 540 px 时背景颜色为蓝色 */ @media screen and (max-width: 539px) { body { background-color: blue; } } /* 3. 540px～970px时背景颜色为绿色 */ @media screen and (min-width: 540px) and (max-width: 969px) { body { background-color: green; } } /* 4. 大于等于970px背景颜色为红色 */ @media screen and (min-width: 970px){ body { background-color: red; } } 因为 CSS 的层叠性原则，3可省略为： @media screen and (min-width: 540px) { body { background-color: green; } } 媒体查询从小到大写，代码更简洁。 2.4. 案例——媒体查询 + rem 实现元素动态大小变化 Zander * { margin: 0; padding: 0; } @media screen and (min-width: 320px){ html { font-size: 50px; } } @media screen and (min-width: 640px){ html { font-size: 100px; } } .top { height: 1rem; font-size: .5rem; background-color: yellow; color: white; text-align: center; line-height: 1rem; } 购物车 2.5. 引入资源 当样式比较繁多的时候，可针对不同的媒体使用不同的 stylesheets。 原理就是直接在 link 中判断设备的尺寸，然后引用不同的css 文件。 语法规范 3. Less 基础 3.1. CSS 的弊端 CSS 是一门非程序式语言，没有变量、函数、Scope 等概念。 css 需要书写大量看似没有逻辑的代码，冗余度较高 不方便维护及扩展，不利于复用 没有良好的计算能力 3.2. Less 介绍 Leaner Style Sheets 是一门 CSS 扩展语言，也是 CSS 的预处理器。它没有减少 CSS 的功能，而是在现有的 CSS 语法上，为 CSS 加入程序式语言的特性。 如引入了变量、Minxin、运算以及函数等功能，大大简化了 CSS 的编写，并且降低了 CSS 的维护成本，Less 可以让我们用更少的代码做更多的事情。 Less 中文网址：http://lesscss.cn/ 3.3. 安装 Less $ npm install -g less 3.4. Less 变量 变量是指没有固定的值，可以改变的。用于 CSS 中一些常用的颜色和数值定义。 @变量名: 指; 变量命名规范 必须有@为前缀 不能包含特殊符号 不能以数字开头 大小写敏感 less 编译 less 文件需要编译生成为 css 文件，这样 html 页面才能使用。 Vscode Less 插件——Easy Less 插件用来把 less 文件编译为 css 文件。安装完后编写完 less 文件保存文件就会自动转换为 css 文件。 less 嵌套 与 Sass 一致 .nav { .logo { ... } } 内层选择器前没有 & 符号，则它被解析为父选择器后代 如果有 & 符号，被解析为父元素自身或父元素的伪类 a { &:hover { color: yellow; } } less 运算 less 中任何的数字、颜色或者变量都可以参与算术运算。 @border: 5px + 5; div { border: @border solid red; } 运算符中间左右有空格隔开 对于两个不同单位的值之间的运算，运算结果的值取第一个值的单位 如果两个值之间只有一个值有单位，则运算结果取该单位 3.5. rem 适配方案 适配的目标是什么？ 怎么去达成这个目标？ 在实际开发中如何使用？ 1. 方案一 less 媒体查询 rem 2. 方案二 flexible.js rem 3.6. 适配方案一 设计稿常见尺寸宽度： 设备 常见宽度 iphone 5 640px iphone 678 750px Android 常见320px、375px、384px、400px、414px、500px、720px 基本以750px 为准。 @media screen and (min-width: 320px) { html { font-size: 21.33px; } } @media screen and (min-width: 750px) { html { font-size: 50px; } } 动态设置html 标签 font-size 大小： 假设设计稿为750px 把整个屏幕分为 15等份（划分标准不一，也可为10份/20份） 每一份作为html字体大小，这里为50px 那么在320px设备时，字体大小为320px/15=21.33px 元素大小取值方法： 页面元素的 rem 值 = 页面元素值（px）/ （屏幕宽度 / 划分的份数） 屏幕宽度/划分的份数就是 html fon-size 的大小 页面元素rem值 = 页面元素值（px）/ html font-size 字体大小 3.7. 适配方案二 flexible.js： 手机淘宝团队发布的简洁高效移动端适配库。不需要写繁琐的媒体查询，js 里做了相应处理，原理是把当前设备分为10等份，但不同设备下，比例相同。 只需要确定当前设备的 html 文字大小即可，比如当前设计稿为 750px，那么只需要把 html 文字大小设置为 75px（710px /10），页面中元素的 rem 值：页面元素的 px 值 / 75。 下载地址：https://github.com/amfe/lib-flexible Zander Hsueh            updated 2022-06-12 18:35:50 "},"Dev/Sass.html":{"url":"Dev/Sass.html","title":"Sass","keywords":"","body":" Sass1. 安装1.1. MacOS 安装1.2. Npm 安装2. 使用2.1. 命令行使用3. Sass 规则3.1. 变量 Variables3.2. 嵌套 Nesting3.3. 混合 Mixins3.4. 继承/扩展 Inheritance3.5. 导入3.6. 注释3.7. 数据类型3.8. 控制指令3.9. 警告与错误 Sass Sass 是世界上最成熟、稳定，功能最强大的专业级 CSS 扩展语言。 ——王婆卖瓜环节 1. 安装 1.1. MacOS 安装 Sass 是使用 Ruby 语言编写的，要使用 Sass 必须先安装 Ruby。 MacOS 上默认已经安装了 Ruby，使用 $ ruby -v 可查看安装情况。 如果没有安装 Ruby，可使用 Homebrew 安装 Ruby：$ brew install ruby 使用 Ruby 安装 Sass：$ sudu gem install sass 国内的 Gem 极慢，可改为使用国内镜像。或者直接使用 Homebrew 安装：$ brew install sass/sass/sass 1.2. Npm 安装 $ npm install -g sass 2. 使用 2.1. 命令行使用 Sass 文件一般指以 .scss 结尾的文件，意为 Sassy CSS，还有一种更旧的语法以 .sass 结尾，需要区分开来。 先编写一段 Sass 代码： $yy: black; ul { width: 100px; li { color: $yy; } } 输入命令将其编译转化为 CSS 代码： $ sass test.scss 也可以将编译的结果保存为文件： $ sass test.sass test.css 输出样式 是否觉得输出的代码格式有些怪异（缩进等）： ul { width: 100px; } ul li { color: black; } /*# sourceMappingURL=01.css.map */ 这是因为采用了默认的代码风格来编译，使用 --style 可指定编译后的 CSS 代码风格，支持一下四种输出样式： nested：默认格式，嵌套缩进。 expanded：平时手动格式化后的样式，无缩进、无嵌套。 compact：一个样式规则处于同一行。 compressed：压缩。 生产环境一般采用压缩的格式。 监听 也可以让SASS监听某个文件或目录，一旦源文件有变动，就自动生成编译后的版本。 # 监听单个文件 $ sass --style expanded --watch test.scss:test.css # 监听文件夹 $ sass --watch app/sass:public/stylesheets 3. Sass 规则 3.1. 变量 Variables 变量以 $ 开头，可以是任何 CSS 的单个/多个值： $primary-color: yellow; $primary-border: 1px solid $primary-color; body { background-color: $primary-color; div { border: $primary-border; } } 使用变量的时候名字中的 - 和 _ 可替换，但尽量保持统一。 3.2. 嵌套 Nesting 基本嵌套 Sass 中的选择器可以嵌套使用，避免重复书写父级选择器/ .nav { background-color: yellow; ul { margin: 0; width: 100px; height: 50px; li { color: red; padding: 0; } } } 嵌套时调用父选择器 嵌套时调用父选择器使用 &，在使用伪类选择器等时较常用： a { font-style: 16px; &:hover { color: blue; } } 嵌套属性 属性也可以嵌套，使用时内部只需要写属性的后半部分： body div { font: { family: Arial, Helvetica; size: 16px; weight: 700; } border: { radius: 12px; color: black; width: 12px; } } 注： 属性的前半部分后面必须加冒号 :。 3.3. 混合 Mixins Mixins 是一段可以重用的代码块。 先使用 @mixin 定义一个代码块： @mixin warning { color: red; background-color: #fff; a { color: yellow; } } 然后可以使用 @include 调用定义的 mixin 代码： .warning-box { @include warning; width: 100px; } 使用参数 @mixin warning($text-color, $bgc-color: red) { color: $text-color; background-color: $bgc-color; a { color: yellow; } } .warning-box { @include warning(yellow, white); width: 100px; } 支持像 ES6 函数的默认参数一样传属性的默认值 。 3.4. 继承/扩展 Inheritance @extend 可继承样式： .father { color: yellow; font-size: 16px; } .father a { font-weight: bold; } .son { @extend .father; font-family: Arial, Helvetica, sans-serif; } 编译后的 CSS： .father, .son { color: yellow; font-size: 16px; } .father a, .son a { font-weight: bold; } .son { font-family: Arial, Helvetica, sans-serif; } 3.5. 导入 Sass 优化了 CSS 的 @import，提高了效率。 新建一个 Partails 文件 _base.scss，写入样式： body { margin: 0; padding: 0; } 再其它 .scss 文件中直接导入即可使用： @import \"./base\"; 注：Partails 文件尽量使用下划线开头，引入时不需要加。 3.6. 注释 Sass 中有三种注释： 1. 单行注释 // 单行注释 单行注释不会出现在编译后的 CSS 文件中。 2. 多行注释 /* * 多行注释 * 天王盖地虎 */ 编译后多行注释只会在没有压缩的 CSS 文件中。 3. 强制注释 /*! 强制输出注释 */ 强制注释在压缩后的 CSS 文件中也出存在。 3.7. 数据类型 Sass 中也有自己的数据类型系统，可在命令行输入 $ sass -i 进入交互模式，然后使用 type-of() 函数判断数据类型。 number 数字可以进行数学运算。 数字函数： abs()：得到绝对值 round()：四舍五入 ceil()：向上取整 floor()： 向下取整 min()：返回最小值，min(1, 2, 3) 返回 1 max()：返回最大值 string 字符串可以使用 + 拼接。 字符串函数： to-upper-case()：转为大写字母 to-lower-case()：转为小写 str-length()：获取字符串长度 str-index()：获取字符串位置，如 str-index(\"hello zander\", \"hello\")返回1，Sass 中索引值从1开始color 颜色包括类如 red、rgb(255, 0, 0)、#fff、hsl(0, 100%, 23%)。 颜色函数： rgb()：生成RGB颜色。 hsla()：HSL颜色加透明度 adjust-hue()：调整色相度数，如 adjust-hue(hsl(1, 100, 50%), 137deg) lighten()：调整颜色明度至更亮，如 lighten(yellow, 30%) darken()：调整颜色明度至更暗 saturate()：调整颜色纯度（饱和度）至更高，如 saturate(#f7dd23, 30%) desaturate()：调整颜色纯度至更高 transparentize()：调整颜色至更透明,，如 transparentize(#f7dd23, .4) opacify()：调整颜色至更不透明list list 指列表类型的值，元素之间使用逗号或空格分隔开，如 border 的值 1px solid #000。列表之间通过逗号或括号分隔开，如 padding 的值 (23px 6px) (3px 8px)。 列表函数： nth()：获取列表中对应下标的值，需注意下标从1开始，如 nth(5px 10px, 1) 得到 5px。 index()：获取列表中元素的下标，如 index(1px solid pink, solid) 返回2，不存在的元素返回 null。 append()：给列表追加元素，第三个参数为可选参数，表示返回列表的分隔符，comma 为逗号，space 为空格。 join()：合并列表，如 join(1px 5px, 10px 6px)。 map map 类型为健值对的数据，如： $map: (key1: value1, key2: value2); map的函数： length()：返回map健值对的个数 map-get()：根据key获取value，如： $color: (dark: #000, light: #fff); body { background-color: map-get($color, dark); } map-keys()：返回一个map所有的key列表。 map-values()：返回一个map所有的value列表。 map-has-key()：判断一个map中是否包含这个key，返回true或false，如 map-has-key($color, dark)。 map-merge()：合并两个map map-remove()：删除map中的元素，如 map-remove($color, dark, light) Boolean Sass 中的且：and 或：or 非：not() Interpolation Interpolation 用于在注释或属性中使用表达式，使用方式为 #{}。如： $version: 0.0.1; $name: \"line\"; $attr: \"border\"; /* 本系统版本为 #{$version} */ .hello-#{$name} { #{$attr}-color: yellow; } 结果为： @charset \"UTF-8\"; /* 本系统版本为 0 0.1 */ .hello-line { border-color: yellow; } /*# sourceMappingURL=01.css.map */ 3.8. 控制指令 @if $isOld: true; div { @if $isOld { -webkit-border-radius: 5px; -moz-border-radius: 5px; } border-radius: 5px; } 还有常见的例子是更换网站日间/夜间模式，使用 @if{}@else if{}@else{}。 @for @for $var from start to end 表示循环从 start 到 end 立即结束，不包含 end： $columns: 4; @for $i from 1 to $columns { .col-#{$i} { width: 100% / $columns * $i; } } 编译结果： .col-1 { width: 25%; } .col-2 { width: 50%; } .col-3 { width: 75%; } @for $var from start through end 表示循环从 start 到 end 结束，包含 end： $columns: 4; @for $i from 1 through $columns { .col-#{$i} { width: 100% / $columns * $i; } } 编译结果： .col-1 { width: 25%; } .col-2 { width: 50%; } .col-3 { width: 75%; } .col-4 { width: 100%; } @each 用法： @each $var in $list { ... } 例子： $list: success error warning; @each $icon in $list { .icon-#{$icon} { background-color: url(./icons/#{$icon}.png); } } 编译结果： .icon-success { background-color: url(./icons/success.png); } .icon-error { background-color: url(./icons/error.png); } .icon-warning { background-color: url(./icons/warning.png); } @while 用法： @while 条件 { ... } 例： $i: 6; @while $i > 0 { .item-#{$i} { width: 5px * $i; } $i: $i - 2; } 编译结果； .item-6 { width: 30px; } .item-4 { width: 20px; } .item-2 { width: 10px; } 自定义函数 用法： @function 名称(参数1, 参数2) { ... } 例： $color: (light: #fff, dark: #000); @function color($key){ @return map-get($color, $key); } .div { background-color: color(dark); } 编译结果： .div { background-color: #000; } 3.9. 警告与错误 警告：@warn 错误：@error 例： $color: (light: #fff, dark: #000); @function color($key){ @if not map-has-key($color, $key) { @warn \"在 $color 中没有找到 #{$key}\"; } @return map-get($color, $key); } .div { background-color: color(hello); } 警告的信息会显示在sass命令行中 错误的信息会直接以注释的形式显示在编译后的结果中 Zander Hsueh            updated 2022-06-12 19:33:26 "},"Dev/Typescript.html":{"url":"Dev/Typescript.html","title":"Typescript","keywords":"","body":" TypeScript1. 简介2. 安装3. Hello TypeScript4. 类型系统4.1. 原始数据类型4.2. 任意值4.3. 类型推论4.4. 联合类型4.5. 对象的类型——接口4.6. 数组类型4.7. 函数类型4.8. 类型断言4.9. 声明文件4.10. 内置对象4.11. 类型别名4.12. 字符串字面量类型4.13. 元组类型4.14. 枚举类型5. 类6. 泛型6.1. 泛型变量6.2. 泛型类型6.3. 泛型接口6.4. 泛型类6.5. 泛型约束7. 声明合并7.1. 函数的合并7.2. 接口的合并8. 声明文件8.1. 书写声明文件步骤9. ts 优缺点 TypeScript 1. 简介 TypeScript是 JavaScript 的一个超集，主要提供了类型系统和对 ES6 的支持，可以编译为纯 JavaScript。由 Microsoft 开发并开源。 目前，Vue 3.0、Angular、React 都使用 TypeScript 作为开发语言。 2. 安装 npm install -g typescript 全局安装 TypeScript 后可在命令行使用tsc命令编译一个 TypeScript 文件。 使用 TypeScript 编写的文件以.ts为后缀，使用 TypeScript 编写 React 时以.tsx为后缀。 TypeScript 大大增强了编辑器和 IDE 的功能，包括代码补全、接口提示、跳转到定义、重构等。尤其 Visual Studio Code，它内置了 TypeScript 支持，并且它本身也是使用 TypeScript 编写的。 3. Hello TypeScript 新建 hello.ts function helloWorld(name: String) { return `Hello ${name}`; } const zander = 'Zander'; console.log(helloWorld(zander)); 编译文件 tsc hello.ts 生成编译好的 JavaScript 文件 function helloWorld(name) { return \"Hello \" + name; } var zander = 'Zander'; console.log(helloWorld(zander)); TypeScript 中，:可以指定变量的类型，编译的时候会进行检查，有错误编译时会报错，但还是会生成 js 文件的编译结果。 hello.ts:7:24 - error TS2345: Argument of type '4444' is not assignable to parameter of type 'String'. 7 console.log(helloWorld(zander)); ~~~~~~ Found 1 error. 4. 类型系统 4.1. 原始数据类型 JavaScript 中数据类型分为两种： 原始数据类型：Boolean、Number、String、null、undefined、Symbol（ES6） 对象类型：Object、Array 先来看看五种原始数据类型在 TypeScript 中是如何使用的： 1. Boolean 定义布尔值类型： let isDone: boolean = false; 不能在 TypeScript 中使用构造函数实例化布尔值对象：let newBoolean: boolean = new Boolean(1)，这种方式返回的是一个 Boolean 对象，应直接调用：let newBoolean: boolean = Boolean(1) 2. Number let num: number = 6; let binary: number = 0b1010; // ES6中的二进制表示法 let notNum = NaN; var num = 6; var binary = 10; // ES6中的二进制表示法 var notNum = NaN; 3. String let myName: string = 'Zander'; let myAge: number = 23; let about: string = `my name is ${myName}, and I am ${myAge}.` var myName = 'Zander'; var myAge = 23; var about = \"my name is \" + myName + \", and I am \" + myAge + \".\"; 4. 空值 JS 中没有空值（void）的概念，但在 TS 中，可以用void表示没有任何返回值的函数： function voidFunc(): void { console.log('this is a void function!') } 声明一个void类型的变量没有什么意义，只能将这个变量赋值为null和undefined： let voidName: void = null; function voidFunc() { console.log('this is a void function!'); } var voidName = null; 5. Null 和 Undefined let u: undefined = undefined; let n: null = null; let num1: number = undefined; let str1: string = n; var u = undefined; var n = null; var num1 = undefined; var str1 = n; null和undefined是所有类型的子类型，可以赋值给其它类型，而void不可以。 4.2. 任意值 任意值（Any）用来表示允许将变量赋值为任意类型。 个人认为 TS 的类型系统相当于将 JS 的“弱类型”、“动态类型”限制为“强类型”、“静态类型”，但 TS 是 JS 的超集，不能摒弃 JS 的这一特性，所以有了 Any。 any类型的变量允许被赋值为任意类型 let any: any = 'six'; any = 6; 允许调用任何方法（方法无实际功能） let anyFunc: any = 'Zander'; anyFunc.hello(); anyFunc.world('heihei'); 可以编译不代表可以运行，这段代码可以编译为 js 文件，但运行还是会报错anyFunc.hello is not a function。 未声明类型的变量会被识别为任意值类型 let name; name = 'zander'; name = 666; 4.3. 类型推论 如果没有在代码中明确指定类型，TS 会依照类型推论的规则推断出一个类型，如果非法，编译时依然会报错。 // 编译时报错 let name = 'zander'; name = 666; 4.4. 联合类型 联合类型表示取值可以为多种类型中的一种，使用|分隔每一种类型。 let strOrNum: number | string; strOrNum = 'zander'; strOrNum = 6; 当变量是联合类型时，只可以访问这些类型的共有方法（toString()、length()等）。 4.5. 对象的类型——接口 在 TypeScript 中，使用接口（Interfaces）来定义对象的类型。 interface Person { name: string; age: number; alive: boolean; } let zander: Person = { name: 'Zander', age: 18, alive: true } var zander = { name: 'Zander', age: 18, alive: true }; 定义的变量属性不能比接口的属性少或多，必须相同。 但可设置可选属性： interface Person { name: string; age?: number; alive?: boolean; } let zander: Person = { name: 'Zander' } 任意属性： interface Person { name: string; age?: number; [propName: string]: any } let zander: Person = { name: 'Zander', hello: 'world', world: 'lalala' } [propName: string]: any可以添加任意个属性，但是定义了任意属性后确定属性和可选属性都必须是相同的类型，即对象里的所有属性必须为同一类型。 只读属性： interface Person { readOnly name: string; } let zander: Person = { name: 'Zander' } zander.name = 'notZander'; // 报错 readOnly可以使属性只能在创建的时候被赋值。 4.6. 数组类型 数组的定义方法： 1. 类型 + 方括号 let arr: number[] = [1, 2, 3, 4, 5]; 上述代码中数组中不能出现除了 number 类型以外的其他类型，指定为any即可添加任意类型的元素。 2. 数组泛型 let arr: Array = [1, 2, 3, 4, 5]; 3. 接口 interface NumberArray { [index: number]: number; } let arr: NumberArray = [1, 2, 3, 4, 5]; 4. 类数组 像函数的参数这种不是数组的类数组不能使用数组的定义方法，要用接口： function zander() { let args: { [index: number]: number; length: number; callee: Function; } = arguments; } ts 已经定义好了常用的类数组接口，如函数的参数： function zander() { let args: IArguments = arguments; } function zander() { var args = arguments; } 4.7. 函数类型 函数是 JavaScript 中的一等公民。 1. 函数声明 // js function sum(x, y) { return x + y; } // ts function sum(x: number, y: number): number { return x + y; } ts 考虑到了函数的输入和输出类型，不可输入多余或少于设定的实参。 2. 函数表达式 // js const sum = function (x, y) { return x + y; } const sum: (x: number, y: number) => number = function (x: number, y: number): number { return x + y; } 此处的=>表示 ts 中的函数定义，左边为输入类型，右边为输出类型，而非 ES6 中的箭头函数。 可选参数 ```ts function zander(firstName: string, lastName?: string): string { if (lastName) { return `${firstName} ${lastName}`; } else { return firstName; } } zander('Zander', 'Xue'); zander('Zander'); ``` ⚠️：可选参数必须在必选参数后，即可选参数后面不允许再出现必需参数。 参数默认值 ts 中，当函数设置了默认参数，会将这个参数识别为可选参数，此时不受可选参数必须在必选参数后的限制。 ```ts function zander(firstName: string, lastName: string = \"Xue\"): string { return `${firstName} ${lastName}`; } zander('Zander'); ``` 重载 重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。 如需要实现一个函数 reverse，输入数字 123 的时候，输出反转的数字 321，输入字符串 'hello' 的时候，输出反转的字符串 'olleh'。且需要精确为输入为数字的时候，输出也应该为数字，输入为字符串的时候，输出也应该为字符串。 ```ts function reverse(x: number): number; function reverse(x: string): string; function reverse(x: number | string): number | string { if (typeof x === 'number') { return Number(x.toString().split('').reverse().join('')); } else if (typeof x === 'string') { return x.split('').reverse().join(''); } } ``` 编译结果： ```js function reverse(x) { if (typeof x === 'number') { return Number(x.toString().split('').reverse().join('')); } else if (typeof x === 'string') { return x.split('').reverse().join(''); } } ``` 4.8. 类型断言 类型断言（Type Assertion）可以用来手动指定一个值的类型。 语法： 值 或 值 as 类型 当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，只能访问此联合类型的所有类型里共有的属性或方法: function getLength(something: string | number): number { return something.length; } // 编译报错，因为number类型没有.length方法 但有些时候需要在还不确定类型的时候就访问其中一个类型的属性或方法，如： function getLength(something: string | number): number { if (something.length) { return something.length; } else { return something.toString().length; } } // 编译仍报错 此时可使用类型断言，将参数断言为 string 类型： function getLength(something: string | number): number { if ((something).length) { return (something).length; } else { return something.toString().length; } } ⚠️：类型断言不是类型转换，断言成一个联合类型中不存在的类型是不允许的。 4.9. 声明文件 此处概念不结合实例难以理解，应在具体项目中加以实践，先放链接，回头敲综合 demo 时结合概念食用。 4.10. 内置对象 JavaScript 中的内置对象可以直接在 ts 中当作定义好的类型。 ECMAScript 中的内置对象 Boolean、Error、Date、RegExp等。 let b: Boolean = new Boolean(true); let e: Error = new Error('error'); let d: Date = new Date(); let r: RegExp = /[a-z]/; DOM 和 BOM 中的内置对象 Document、HTMLElement、Event、NodeList等。 let body: HTMLElement = document.body; let allDiv: NodeList = document.querySelectorAll('div'); document.addEventListener('click', function(e: MouseEvent) { console.log('zander'); }); 编译结果： var body = document.body; var allDiv = document.querySelectorAll('div'); document.addEventListener('click', function (e) { console.log('zander'); }); TypeScript 核心库的定义文件中内置了所有浏览器环境需要用到的类型，所以才有不符合类型时的报错，ts 内部做了类型校验。但核心库的定义中不包含 Node.js 部分，要使用 ts 写 node 需要引入： npm install @types/node --save-dev 4.11. 类型别名 使用 type 可创建类型别名，常用于联合类型。 type numberAlias = number; let a: numberAlias = 999; 编译结果： var a = 999; 4.12. 字符串字面量类型 字符串字面量类型用来约束取值只能是某几个字符串中的一个，也是使用type进行定义。 type eventType = 'click' | 'mouseover' | 'scroll'; function handleEvenet(ele: Element, event: eventType) { console.log('zander'); } handleEvenet(document.getElementById('div'), 'click'); // 正确 handleEvenet(document.getElementById('div'), 'mousemove'); // 报错 4.13. 元组类型 ts 中的数组的元素都为同一类型，而要存储不同类型的数据需要使用元组。 let zander: [string, number] = ['Zander', 23]; 可以给元组的元素单独赋值，但直接给元素赋值时需要提供所有的元组类型： let zander: [string, number]; zander[0] = \"Zander\"; zander[1] = \"Xue\"; // 报错 zander = [\"Zander\", 23]; zander = [\"Zander\"]; // 报错 4.14. 枚举类型 枚举（Enum）类型用于取值被限定在一定范围内的场景，比如一周只能有七天，颜色限定为红绿蓝等，使用enum定义。ts 支持基于数字和字符串的枚举。 数字枚举 枚举成员会默认被赋值为从 0 开始递增的数字，也可以初始化成员的数值： enum Week { Sun, Mon, Tue, Wed, Thu, Fri, Sat } // 默认 console.log(Week[\"Sun\"] === 0); // true console.log(Week[0] === \"Sun\"); // true enum Week2 { Sun = 1, Mon, Tue, Wed, Thu, Fri, Sat } // 初始化 编译结果： // 原理：反向映射表 var Week; (function (Week) { Week[Week[\"Sun\"] = 0] = \"Sun\"; Week[Week[\"Mon\"] = 1] = \"Mon\"; Week[Week[\"Tue\"] = 2] = \"Tue\"; Week[Week[\"Wed\"] = 3] = \"Wed\"; Week[Week[\"Thu\"] = 4] = \"Thu\"; Week[Week[\"Fri\"] = 5] = \"Fri\"; Week[Week[\"Sat\"] = 6] = \"Sat\"; })(Week || (Week = {})); console.log(Week[\"Sun\"] === 0); // true console.log(Week[0] === \"Sun\"); // true 字符串枚举 在一个字符串枚举里，每个成员都必须用字符串进行初始化。 enum Gender { Male = \"MALE\", Female = \"Female\", Unknow = \"UNKNOW\" } 编译结果： var Gender; (function (Gender) { Gender[\"Male\"] = \"MALE\"; Gender[\"Female\"] = \"Female\"; Gender[\"Unknow\"] = \"UNKNOW\"; })(Gender || (Gender = {})); 常量枚举（const枚举） 常量枚举是使用 const enum 定义的枚举类型，它会在编译阶段被删除，并且不能包含计算成员。 const enum Week { Sun, Mon, Tue, Wed, Thu, Fri, Sat } 编译结果： var week = [0 /* Sun */, 1 /* Mon */, 2 /* Tue */, 3 /* Wed */, 5 /* Fri */, 6 /* Sat */]; 5. 类 回顾类的相关概念： 类(Class)：定义了一件事物的抽象特点，包含它的属性和方法 对象（Object）：类的实例，通过 new 生成 面向对象（OOP）的三大特性：封装、继承、多态 封装（Encapsulation）：将对数据的操作细节隐藏起来，只暴露对外的接口。外界调用端不需要（也不可能）知道细节，就能通过对外提供的接口来访问该对象，同时也保证了外界无法任意更改对象内部的数据 继承（Inheritance）：子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性 多态（Polymorphism）：由继承而产生了相关的不同的类，对同一个方法可以有不同的响应。比如 Cat 和 Dog 都继承自 Animal，但是分别实现了自己的 eat 方法。此时针对某一个实例，我们无需了解它是 Cat 还是 Dog，就可以直接调用 eat 方法，程序会自动判断出来应该如何执行 eat 存取器（getter & setter）：用以改变属性的读取和赋值行为 修饰符（Modifiers）：修饰符是一些关键字，用于限定成员或类型的性质。比如 public 表示公有属性或方法 抽象类（Abstract Class）：抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现 接口（Interfaces）：不同类之间公有的属性或方法，可以抽象成一个接口。接口可以被类实现（implements）。一个类只能继承自另一个类，但是可以实现多个接口 传统的 JavaScript 使用函数和基于原型的继承来创建可重用的组件（类），从 ES6 开始新增了 class。TypeScript 除了实现了所有 ES6 中的类的功能以外，还添加了一些新的用法。 class Greeter { greeting: string; constructor(message: string) { this.greeting = message; } greet() { return 'Hello, ' + this.greeting; } } let greeter = new Greeter('world'); 编译结果： var Greeter = /** @class */ (function () { function Greeter(message) { this.greeting = message; } Greeter.prototype.greet = function () { return 'Hello, ' + this.greeting; }; return Greeter; }()); var greeter = new Greeter('world'); 继承 class Animal { constructor(name: string) { this.name = name; } alive(age: number = 0) { console.log(`This animal is ${age} years old.`); } } class Dog extends Animal { constructor(name: string) { super(name); } alive(age = 10) { console.log(`I am ${age} years old!`); } bark() { console.log('Woof! Woof!'); } } const dog = new Dog(); dog.bark(); dog.alive(10); dog.bark(); 此处的 Dog 是一个派生类，它派生自 Animal 基类，通过 extends 关键字。 派生类通常被称作子类，基类通常被称作超类。 但是在 ts 中有一条重要的规则，如上述代码所示，派生类包含了一个构造函数name，它必须调用super()方法，它会执行基类的构造函数。在构造函数里访问 this 的属性之前，必须要调用 super()。 而且，Dog 中重写了 Animal 中定义的alive方法，使其具有不同的功能。 公共，私有与受保护的修饰符 1. public 在TypeScript里，成员都默认为public。 2. private 当成员被标记成 private时，它就不能在声明它的类的外部访问。 class Animal { private name: string; constructor(theName: string) { this.name = theName; } } new Animal(\"Cat\").name; // 错误: 'name' 是私有的. 3. protected protected修饰符与 private修饰符的行为很相似，但有一点不同， protected成员在派生类中仍然可以访问。 class Person { protected name: string; constructor(name: string) { this.name = name; } } class Employee extends Person { private department: string; constructor(name: string, department: string) { super(name) this.department = department; } public getName() { return `Hello, my name is ${this.name} and I work in ${this.department}.`; } } let zander = new Employee(\"Zander\", \"西安开发中心\"); console.log(zander.getName()); console.log(zander.name); // 错误 ⚠️：不能在 Person 类外直接使用 name，但是可以通过 Employee类的实例方法访问。 4. readonly readonly关键字可将属性设置为只读的，只读属性必须在声明时或构造函数里被初始化。 class Person { readonly name: string; readonly age: number = 8; constructor (theName: string) { this.name = theName; } } let zander = new Person(\"Zander\"); zander.name = \"Tom\"; // 错误! name 是只读的 使用参数属性在构造函数前创建并初始化参数，可简化构造函数的赋值： class Person { readonly age: number = 8; constructor(readonly name: string) { } } 静态属性 类的静态成员存在于类本身上面而不是类的实例上。 class Grid { static origin = {x: 0, y: 0}; calculateDistanceFromOrigin(point: {x: number; y: number;}) { let xDist = (point.x - Grid.origin.x); let yDist = (point.y - Grid.origin.y); return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale; } constructor (public scale: number) { } } let grid1 = new Grid(1.0); // 1x scale let grid2 = new Grid(5.0); // 5x scale console.log(grid1.calculateDistanceFromOrigin({x: 10, y: 10})); console.log(grid2.calculateDistanceFromOrigin({x: 10, y: 10})); 在这个例子里，使用 static定义 origin，因为它是所有网格都会用到的属性。每个实例想要访问这个属性的时候，都要在 origin前面加上类名。如同在实例属性上使用 this.前缀来访问属性一样，这里使用 Grid.来访问静态属性。 抽象类 abstract用于定义抽象类和其中的抽象方法。 抽象类不允许被实例化 abstract class Animal { public name; public constructor(name) { this.name = name; } public abstract sayHi(); } let a = new Animal('Jack'); // 报错 抽象类中的抽象方法必须被子类实现 abstract class Animal { public name; public constructor(name) { this.name = name; } public abstract sayHi(); } class Cat extends Animal { public eat() { console.log(`${this.name} is eating.`); } } let cat = new Cat('Tom'); // 报错，Cat 中必须实现 salHi 方法 6. 泛型 泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。有利于组件的可复用性。 function zander(arg: T): T { return arg; } 类型变量 T 可捕获用户传入的类型（比如：number），之后就可以使用这个类型。比如再次使用了 T 当做返回值类型。 与使用any定义参数和返回值不同，any不能保证传入的类型与返回的类型相同。 定义了泛型函数后，有两种使用方法： 传入所有的参数，包含类型参数 function zander(arg: T): T { return arg; } const hello = zander('hello'); 类型推论 即编译器会根据传入的参数自动地确定 T 的类型，更常用。 const hello = zander('hello'); 6.1. 泛型变量 如果想要获取传入参数的length属性时，直接使用会报错，因为不确定传入的参数是否有length属性（如 number 类型）： function zander(arg: T): T { console.log(arg.length); // 报错 return arg; } 可以使用泛型变量指定参数的类型来使用该类型参数具有的属性： function zander(arg: T[]): T[] { console.log(arg.length); // 正确 return arg; } zander([22, 33]); 6.2. 泛型类型 泛型函数的类型与非泛型函数的类型没什么不同，只是有一个类型参数在最前面，像函数声明一样： function zander(arg: T): T { return arg; } let zander1: (arg: T) => T = zander; 6.3. 泛型接口 interface zander { (arg: T): T; } function zanderFunc(arg: T): T { return arg; } let zander1: zander = zanderFunc; 6.4. 泛型类 泛型类看上去与泛型接口差不多。 泛型类使用<>括起泛型类型，跟在类名后面。 无法创建泛型枚举和泛型命名空间。 class Add { zeroValue: T; add: (x: T, y: T) => T; } let add = new Add(); add.zeroValue = 0; add.add = function(x, y) { return x + y; }; let add = new GenericNumber(); // 可指定任意类型 add.zeroValue = \"\"; add.add = function(x, y) { return x + y; }; console.log(add.add(add.zeroValue, \"test\")); ⚠️：类有两部分：静态部分和实例部分。 泛型类指的是实例部分的类型，所以类的静态属性不能使用这个泛型类型。 6.5. 泛型约束 像上面使用length 属性的例子，也可限制函数去处理任意带有.length属性的所有类型。只要传入的类型有这个属性，就允许。这就是泛型约束。 interface Lengthwise { length: number; } function zander(arg: T): T { console.log(arg.length); // T 一定具有lenth属性 return arg; } zander(6); // 报错 zander({length: 10, value: 6}); 编译结果： function zander(arg) { console.log(arg.length); // T 一定具有lenth属性 return arg; } // zander(6); // 报错 zander({ length: 10, value: 6 }); 7. 声明合并 “声明合并”是指编译器将针对同一个名字的两个独立声明合并为单一声明。 合并后的声明同时拥有原先两个声明的特性。 任何数量的声明都可被合并；不局限于两个声明。 简单来说：如果定义了两个相同名字的函数、接口或类，那么它们会合并成一个类型。 7.1. 函数的合并 function reverse(x: number): number; function reverse(x: string): string; function reverse(x: number | string): number | string { if (typeof x === 'number') { return Number(x.toString().split('').reverse().join('')); } else if (typeof x === 'string') { return x.split('').reverse().join(''); } } 7.2. 接口的合并 最简单也最常见的声明合并类型，合并的机制是把双方的成员放到一个同名的接口里。 interface Box { height: number; width: number; } interface Box { scale: number; } let box: Box = {height: 5, width: 6, scale: 10}; 接口的非函数的成员应该是唯一的。如果它们不是唯一的，那么它们必须是相同的类型。如果两个接口中同时声明了同名的非函数成员且它们的类型不同，则编译器会报错。 对于函数成员，每个同名函数声明都会被当成这个函数的一个重载。同时需要注意，当接口A与后来的接口A合并时，后面的接口具有更高的优先级。如： interface Cloner { clone(animal: Animal): Animal; } interface Cloner { clone(animal: Sheep): Sheep; } interface Cloner { clone(animal: Dog): Dog; clone(animal: Cat): Cat; } 合并为一个声明： interface Cloner { clone(animal: Dog): Dog; clone(animal: Cat): Cat; clone(animal: Sheep): Sheep; clone(animal: Animal): Animal; } 8. 声明文件 在JavaScript中一个库有很多使用方式，这就需要书写声明文件去匹配它们。 8.1. 书写声明文件步骤 1. 识别库的类型 全局库 全局库是指能在全局命名空间下访问的（不需要使用任何形式的import）。许多全局库都是简单的暴露出一个或多个全局变量。如 jq 中的$变量可以被简单的引用： $(() => { console.log('hello!') }) 全局库的常用引用方式即在 HTML 文件的标签中： \"> 全局库源码的特性： 顶级的var语句或function声明 一个或多个赋值语句到window.someName 存在 DOM 对象document或window 不存在require或define调用 全局库导入模板 模块化库 一些库只能工作在模块加载器的环境下。比如，express 只能在 Node.js 里工作所以必须使用 CommonJS 的require函数加载。 ES6 后，CommonJS 和 RequireJS 具有相同的导入模块作用。例如，对于JavaScript CommonJS（Node.js）： var fs = require(\"fs\"); ES6 import导入： import fs = require(\"fs\"); 模块化库源码的特性： 调用require或define 存在import、export声明 赋值给exports或module.exports 极少包含window或global的赋值 UMD UMD 模块是指那些既可以作为模块使用（通过导入）又可以作为全局（在没有模块加载器的环境里）使用的模块。 如 Moment.js、Lodash 等，在Node.js或RequireJS里: import moment = require(\"moment\"); console.log(moment.format()); 也可以通过全局变量使用： console.log(moment.format()); UMD 库源码的特性： 模块加载器环境 (function (root, factory) { if (typeof define === \"function\" && define.amd) { define([\"libName\"], factory); } else if (typeof module === \"object\" && module.exports) { module.exports = factory(require(\"libName\")); } else { root.returnExports = factory(root.libName); } }(this, function (b) { 文件的顶端存在typeof define，typeof window，或typeof module这样的测试 常用的第三方库都已经存在了声明文件，但也需要知道一些基本知识，如使用declare来定义类型。 9. ts 优缺点 作者 使用者 优点 清晰的函数参数/接口属性；静态检查；生成api文档 清晰的函数参数/接口属性；配合现代编辑器，各种提示 缺点 标记类型；声明(interface/type) 与某些库配合度不是很完美（vue 2.x） 学习链接 官方文档 TypeScript 入门教程 一篇朴实的文章带你30分钟捋完TypeScript,方法是正反对比 Zander Hsueh            updated 2022-06-12 19:27:57 "},"Economics/经济学原理——微观经济学.html":{"url":"Economics/经济学原理——微观经济学.html","title":"经济学原理——微观经济学","keywords":"","body":"1. 第1章 经济学十大原理——即将到来的魅力的预演1.1. 人们如何做出决策1.2. 人们如何相互影响1.3. 整体经济如何运行2. 第2章 像经济学家一样思考2.1. 作为科学家的经济学家2.2. 作为政策顾问的经济学家2.3. 经济学家意见分歧的原因2.4. 经济学中的图形3. 第3章 相互依存性与贸易的好处4. 第4章 供给与需求的市场力量4.1. 市场与竞争4.2. 需求4.3. 供给4.4. 供给与需求的结合5. 第5章 弹性及其作用5.1. 需求弹性5.2. 供给弹性5.3. 供给、需求和弹性的三个应用6. 第6章 供给、需求与政府政策6.1. 价格控制6.2. 税收7. 第7章 消费者、生产者与市场效率7.1. 消费者剩余7.2. 生产者剩余7.3. 市场效率7.4. 市场效率与市场失灵8. 第8章 应用：赋税的代价8.1. 赋税的无谓损失8.2. 决定无谓损失的因素8.3. 税收变动时的无谓损失和税收收入9. 第9章 应用：国际贸易9.1. 决定贸易的因素9.2. 贸易的赢家和输家9.3. 各种限制贸易的观点10. 第10章 外部性10.1. 外部性和市场无效率10.2. 针对外部性的公共政策10.3. 外部性的私人解决方法11. 第11章 公共物品和公共资源11.1. 不同类型的物品11.2. 公共物品11.3. 公共资源12. 第12章 税制的设计12.1. 税收和效率12.2. 税收与平等13. 第13章 生产成本13.1. 什么是成本13.2. 生产与成本13.3. 成本的各种衡量指标13.4. 短期成本与长期成本14. 第14章 竞争市场上的企业14.1. 什么是竞争市场14.2. 利润最大化与竞争企业的供给曲线14.3. 竞争市场的供给曲线15. 第15章 垄断15.1. 为什么会产生垄断15.2. 垄断者如何做出成产与定价决策15.3. 垄断的福利代价15.4. 价格歧视15.5. 针对垄断的公共政策15.6. 垄断的普遍性16. 第16章 垄断竞争16.1. 在垄断和完全竞争之间16.2. 差别产品的竞争16.3. 广告17. 第17章 寡头17.1. 只有少数几个卖者的市场17.2. 合作经济学17.3. 针对寡头的公共政策18. 第18章 生产要素市场18.1. 劳动的需求18.2. 劳动的供给18.3. 劳动市场的均衡18.4. 其它生产要素：土地和资本19. 第19章 收入与歧视19.1. 决定均衡工资的若干因素19.2. 歧视经济学20. 第20章 收入不平等与贫困20.1. 不平等的衡量20.2. 收入再分配的政治哲学20.3. 减少贫困的政策21. 第21章 消费者选择理论21.1. 预算约束：消费者能买得起什么21.2. 偏好：消费者想要什么21.3. 最优化：消费者选择什么21.4. 三种应用22. 第22章 微观经济学前沿22.1. 不对称信息22.2. 政治经济学22.3. 行为经济学 “经济学是一门研究人类一般生活事务的学问。” —— Alfred Marshall 学习经济学的原因： 理解你所生活在其中的世界； 使你更精明地参与经济； 使你更好地理解经济政策的潜力和局限性。 1. 第1章 经济学十大原理——即将到来的魅力的预演 oikonomons --> economy “管理一个家庭的人”：家庭 & 经济 稀缺性（scarxity）：社会资源的有限性 经济学（economics）：研究社会如何管理自己的稀缺资源 1.1. 人们如何做出决策 原理一： 人们面临权衡取舍 “鱼与熊掌不可兼得” “大炮与黄油” 概念 英文 含义 效率 efficiency 社会能从其稀缺资源中得到最大利益的特性（经济蛋糕的大小） 平等 equality 经济成果在社会成员中平均分配的特性（如何分割经济蛋糕） 当政府想要把经济蛋糕切粉得更均匀时，这块蛋糕本身也变小了（影响了高级烘培师&#x1F468;‍&#x1F373;的热情） 只有充分了解各个选择带来的结果，才能做出更好更长远的决策。 原理二：某种东西的成本是为了得到它所放弃的东西 机会成本（opportunity cost）：为了得到某种东西所必须放弃的东西 当做出任何一项关键决策时，都应该认识到每一种选择所带来的机会成本。 原理三：理性人考虑边际量 理性人（rational people）：系统而有目的地尽最大努力实现其目标的人 边际变动（marginal change）：对行动计划的微小增量调整 当且仅当一种行为的边际收益大于边际成本时，才应该采取这种行为。（人们愿意为钻石支付比水高的价格） 原理四：人们会对激励做出反应 激励（incentive）：引起一个人做出某种行为的某种东西 1.2. 人们如何相互影响 原理五：贸易可以使每个人的状况都变得更好 贸易可以使一个人/一个家庭/一个国家做自己最擅长的活动。 原理六：市场通常是组织经济活动的一种好方法 市场经济（market economy）：当许多企业和家庭在物品与服务市场上相互交易时，通过它们的分散决策配置资源的经济。 为什么象征“人人为己”的市场经济能成功？ 答：“看不见的手”——市场，利己心导致价格的变动与调整 当政府阻止价格根据供求状况自发调整时，它就限制了看不见的手对经济的千百万家庭和企业的决策进行协调的能力。（调整税收扭曲了价格） 原理七：政府有时可以改善市场结果 为什么经济中需要政府？ 市场经济需要规则和制度 促进效率或促进平等 效率目标：因外部性原因或市场势力导致市场失灵； 平等目标：所得税、福利制度等平等的经济福利分配 产权(property rights)：个人拥有并控制稀缺资源的能力。 市场失灵（market failure）：市场本身不能有效配置资源的情况。 外部性（externality）：一个人的行为对旁观者福利的影响。 市场势力（market power）：单个经济活动者(或某个经济活动小群体)对市场价格有显著影响的能力。 1.3. 整体经济如何运行 原理八：一国的生活水平取决于它生产物品与服务的能力 生产率（productivity）：每单位劳动投入所生产的物品与服务数量。 原理九：当政府发行了过多货币时，物价上升 通货膨胀（inflation）：经济中物价总水平的上升。 原理十：社会面临通货膨胀与失业之间的短期权衡取舍 经济周期（business cycle）：就业和生产等经济活动的波动。 短期中控制经济： 增加货币量刺激社会的整体支出水平，从而增加对物品和服务的需求 需求增加后企业提高物价、雇用更多工人，生产更多物品与服务 达到减少失业率的目的 破窗谬论：无事生非的青少年用砖块打碎面包店的窗户，面包师不得不花钱修理，从而增加了修理工的收入，他将增加的收入用于支出，又增加了其他商家的收入，以此类推。如果打破的窗户足够大，支出链以倍数增加，它很可能会带来一轮经济繁荣。 但事实是如果面包师没有将钱用于修理窗户，那他可能会用于买一套新衣服，裁缝就会获得收入，以此类推。破窗并没有引起新的净支出，而是转移了支出活动。人们看到了发生的活动，但没有看到本来会发生的活动。 2. 第2章 像经济学家一样思考 2.1. 作为科学家的经济学家 利用科学方法去观察经济状况，得到理论，再进一步观察确认理论，但经济学中的实验数据往往是世界提供的。 做出假设可以使问题简单化。 经济模型可以加深对现实的理解且简化现实。 循环流量图（circular-flow diagram）：一个说明货币如何通过市场在家庭与企业之间流动的直观经济模型。 生产可能性边界（production possibilities frontier）：表示在可得到的生产要素与生产技术既定时，一个经济条件所能生产的产品数量的各种组合的图形。 生产可能性边界上的点是有效率的生产水平，C点是不可能达到的产量水平，D点是无效率的结果，因为小于所能得到的最大可能产量。 微观经济学：研究家庭和企业如何做出决策，以及它们如何在市场上相互交易的学科。 宏观经济学：研究整体经济现象，包括通货膨胀、失业和经济增长的学科。 2.2. 作为政策顾问的经济学家 当经济学家试图去解释世界时，他们是科学家；当经济学家试图去帮助改善世界时，他们是政策顾问。 实证表述（positive statement）：试图描述世界是什么样子的观点。 规范表述（normative statement）：试图描述世界应该是什么样子的观点。 反托拉斯法即反垄断法。 大多数政策决策中都涉及权衡取舍，一项能提高效率的政策很可能会以损害平等为代价。 2.3. 经济学家意见分歧的原因 “如果让所有的经济学家围坐在一起，他们不会达成任何一个共识。”——萧伯纳 原因： 科学判断的不同 价值观的不同 政治过程中施加的力量和约束 2.4. 经济学中的图形 使用图形的两个目的： 当建立经济理论时，图形提供了一种直观地表述思想的方法； 当分析经济数据时，图形提供了一种发现和解释数据的变动模式的有效方法。 单变量图形 饼形图 柱形图 时间序列图 两个变量的图形：坐标系 正相关与负相关 需求曲线 斜率 斜率 = △y/△x 图形中需要注意的点 忽略的变量 打火机没有引起癌症（忽略了抽烟数量） 反向因果关系 家用旅行车没有引起家庭人口增加（预期到孩子出生才会买家用旅行车） 3. 第3章 相互依存性与贸易的好处 绝对优势（absolute advantage）：一个生产者用比另一个生产者更好的投入生产某种物品的能力。 比较优势（comparative advantage）：一个生产者以低于另一个生产者的机会成本生产某种物品的能力。 专业化和贸易的好处不是基于绝对优势，而是基于比较优势。 贸易可以使社会上每个人都获益，因为它使人们可以专门从事他们具有比较优势的活动。 案例 Zander 一小时可以摘10个椰子&#x1F965;或捕1条鱼&#x1F41F;，他的朋友 Dog 每小时可以摘30个椰子或捕两条鱼，Zander 和 Dog 捕1条鱼的机会成本分别是多少？谁在捕鱼方面有绝对优势？谁有比较优势？ Zander 捕一条鱼需要放弃10个椰子，Dog 捕一条鱼需要放弃15个椰子，所以他们的机会成本分别为10个椰子和15个椰子，Zander 有比较优势，Dog 一个小时两条鱼，Zander 一个小时一条鱼，所以 Dog 有绝对优势。 进口品（imports）：在国外生产而在国内销售的物品。 出口品（exports）：在国内生产而在国外销售的物品。 难题解析 P66.5.假设在美国生产一架飞机要用1万小时劳动，生产一件衬衣要用2小时劳动。在中国，生产一架飞机要用4万小时劳动，生产一件衬衣要用4小时劳动。这两个国家将进行哪种贸易？ A. 中国将出口飞机，美国将出口衬衣 B. 中国将出口衬衣，美国将出口飞机 C. 两国都出口衬衣 D. 在这种情况下贸易不会带来好处 这题中很容易把飞机和衬衣的机会成本都认为是时间，从而得到美国生产飞机和衬衣的机会成本都小于中国的结论，其实不然，机会成本指你要得到这件东西需要同时放弃的其他物品，比如美国生产一架飞机需要1万小时，那么他如果用这1万小时去生产衬衣可以得到5000件衬衣，这就是美国生产一架飞机的机会成本，而中国生产一架飞机是4万/4 = 1万件衬衣的机会成本，所以美国在生产飞机上有比较优势，应出口飞机，衬衣则同理。正确答案为B 4. 第4章 供给与需求的市场力量 供给与需求理论考虑买者与卖者的行为，以及他们相互之间的影响，该理论将说明市场经济中供给与需求如何决定价格，以及价格又如何配置经济中的稀缺资源。 4.1. 市场与竞争 市场（market）：由某种物品或服务的买者与卖者组成的一个群体。 竞争市场（competitive market）：有许多买者与卖者，以至于每个人对市场价格的影响都微乎其微的市场。（如冰淇淋市场） 市场一般分为三种： 完全竞争市场： 可供销售的物品是完全相同的 买者和卖者人数众多，以至于没有任何一个买者和卖者可以影响市场价格 垄断市场 介于完全竞争与垄断之间 4.2. 需求 需求量（quantity demanded）：买者愿意并且能够购买的一种物品的数量。 需求定理（law of demand）：认为在其他条件不变时，一种物品的价格上升，对该物品的需求量减少的观点。 需求表（demand schedule）：表示一种物品的价格与需求量之间关系的表格。 需求曲线（demand curve）：表示一种物品的价格与需求量之间关系的图形。 需求曲线向右下方倾斜是因为在其他条件不变的情况下，更低的价格意味着更多的需求量。 市场需求是所有个人需求之和。 使需求曲线移动的一些重要因素： 收入 当收入减少时，如果一种物品的需求量减少，这种物品就被称为正常物品。 正常物品（normal good）：在其他条件相同时，收入增加引起需求量增加的物品。 当收入减少时，如果一种物品的需求量增加，这种物品就被称为低档物品。（如坐公共汽车） 低档物品（inferior good）：在其他条件相同时，收入增加引起需求量减少的物品。 相关物品的价格 当一种物品价格下降，引起另一种物品的需求量减少时，这两种物品被称为替代品（substitutes）。（如冰淇淋与冷冻酸奶、毛衣与长袖衫等） 当一种物品价格上升，引起另一种物品的需求量减少时，这两种物品被称为互补品（complements）。（如汽油和汽车、电脑和软件等） 爱好 预期 买者的数量 &#x1F914;：烟草与非法毒品大麻在市场需求中是替代品还是互补品？ 4.3. 供给 供给量（quantity supplied）：卖者愿意并且能够出售的一种物品的数量。 供给定理（law of supply）：认为在其他条件不变时，一种物品的价格上升，该物品的供给量增加的观点。 供给表（supply schedule）：表示一种物品的价格与供给量之间关系的表格。 供给曲线（supply curve）：表示一种物品的价格与供给量之间关系的图形。 供给曲线向右上方倾斜是因为在其他条件不变的情况下，更高的价格意味着更多的供给量。 同样的，市场供给是所有卖者供给的总和。 使供给曲线移动的一些重要因素： 投入品价格 一种物品的供给量与生产这种物品所用的投入品的价格负相关。 技术 技术进步可降低企业生产成本，从而增加物品供给量。 预期 卖者的数量 4.4. 供给与需求的结合 供给与需求结合指将需求曲线和供给曲线放在同一坐标轴中来说明他们如何决定市场上一种物品的价格和销售量。 均衡（eqiulibrium）：市场价格达到使供给量与需求量相等的水平时的状态。 均衡价格（eqiulibrium price）：使供给与需求平衡的价格。 均衡数量（eqiulibrium quantity）：均衡价格下的供给量与需求量。 在均衡价格时，买者愿意而且能够购买的物品量正好与卖者愿意而且能够出售的数量相平衡。市场上的每个人都得到了满足。 过剩（surplus）：供给量大于需求量的状态。（也称超额供给） 措施：卖者降低物品价格，使需求量提升，并减少供给量，达到平衡。 短缺（shortage）：需求量大于供给量的状态。（也称超额需求） 措施：卖者提升物品价格。 供求定理（law of supply and demand）：任何一种物品的价格都会自发调整，使该物品的供给与需求达到平衡的观点。 当某些事件使需求/供给曲线移动时，市场上的均衡就改变了。分析均衡变动的三个步骤： 确定该事件是使供给曲线移动还是使需求曲线移动，还是使两者都移动 确定曲线移动的方向 用供求图说明这种移动如何改变均衡价格和均衡数量 供给未变 供给增加 供给减少 需求未变 价格相同，数量相同 价格下降，数量增加 价格上升，数量减少 需求增加 价格上升，数量增加 价格不确定，数量增加 价格上升，数量不确定 需求减少 价格下降，数量增加 价格下降，数量不确定 价格不确定，数量减少 在市场经济中，价格是引导经济决策从而配置稀缺资源的信号。对于经济中的每一种物品来说，价格确保供给与需求达到平衡，均衡价格决定了买者选择购买多少这种物品，以及卖者选择生产多少这种物品。 5. 第5章 弹性及其作用 弹性衡量买者与卖者对市场条件变化的反应程度。 5.1. 需求弹性 弹性（elasticity）：衡量需求量或供给量对其某种决定因素的变动的反应程度的指标。 需求价格弹性（price elasticity of demand）：衡量一种物品需求量对其价格变动反应程度的指标，用需求量变动百分比除以价格变动百分比来计算。 需求价格弹性的决定因素： 相近替代品的可获得性 有相近替代品的物品的需求往往较富有弹性，因为消费者从这种物品转向其他物品比较容易。 如黄油和人造黄油，相反的，鸡蛋价格的小幅度上升并不会引起鸡蛋销售量的大幅减少。 必需品与奢侈品 必需品的需求往往缺乏弹性，而奢侈品的需求往往较富有弹性。但某种物品是必需品还是奢侈品并不取决于物品本身的固有性质，而是取决于购买者的偏好。 比如对一个热衷于航海而不太关注自身健康的水手来说，游艇可能是必需品，而看病则是奢侈品。 市场的定义 任何一个市场上的需求弹性都取决于我们如何划定市场的边界。狭窄定义的市场的需求弹性往往大于宽泛定义的市场的需求弹性。 如食物这个宽泛定义的类别的需求弹性较巧克力冰淇淋这个很狭窄定义的类别小很多，因为食物没有什么可替代品。 时间范围 物品的需求往往在长期内更富有弹性。 汽油价格上升，最初的几个月汽油需求量只是略有减少，随着时间的推移更多的人们购买电动汽车，需求量就会更大幅减少。 需求价格弹性 = 需求量变动百分比/价格变动百分比 需求价格弹性越大，意味着需求量对价格变动的反应越大。 中点法计算变动百分比和弹性： 为避免变动百分比根据不同的基础计算导致不同的结果，通常使用中点法计算弹性 如计算需求曲线上两点(Q1, Q2),(P1, P2)之间的弹性： 当弹性大于1时，需求是富有弹性的，小于1缺乏弹性，等于1具有单位弹性。 通过某点的需求曲线越平坦，需求价格弹性越大；越陡峭，弹性越小。 总收益（total revenue）：一种物品的买者支付从而卖者得到的量，用该物品的价格乘以销售量来计算。 总收益的变动与弹性的大小有关： 需求缺乏弹性时，价格和总收益同方向变动，如果价格上升，总收益增加。 富有弹性时，价格和总收益反方向变动，如果价格上升，总收益减少。 单位弹性时，价格变动总收益保持不变。 需求收入弹性（income elasticity of demand）：\u001c衡量一种物品需求量对消费者收入变动反应程度的指标。 需求收入弹性 = 需求量变动百分比/收入变动百分比 需求的交叉价格弹性（cross-price elasticity of demand）：衡量一种物品需求量对另一种物品价格变动的反应程度的指标。 需求的交叉价格弹性 = 物品1的需求量变动百分比/物品2的价格变动百分比 5.2. 供给弹性 供给价格弹性（price elasticity of supply）：衡量一种物品供给量对其价格变动反应程度的指标。 供给价格弹性的决定因素： 卖者改变他们所生产物品量的灵活性 所考虑的时间长短 供给价格弹性 = 供给量变动百分比/价格变动百分比 5.3. 供给、需求和弹性的三个应用 1. 农业的好消息可能对农民来说是坏消息吗？ 新杂交品种的发现影响了供给曲线，供给曲线向右移动，价格下降，数量提升，那么农民的总收益到底是下降还是提升？取决于需求弹性，小麦这种基本食品缺乏需求弹性，因此小麦价格大幅度下降，减少了农民的总收益。 2. 为什么石油输出国组织不能保持石油的高价格？ 需求与供给在短期与长期中的状况是不同的，短期中，石油的供给和需求较为缺乏弹性，供给缺乏弹性是因为购已知的石油贮藏量和石油开采能力不能迅速改变，需求缺乏弹性是因为购买习惯不会立即对价格变动做出反应。 3. 禁毒增加还是减少了与毒品相关的犯罪？ 禁毒政策增加了出售毒品的成本（制止毒品进入国内并逮捕走私者），减少了毒品的供给量，使供给曲线向左移动，毒品价格提升，数量减少。但毒品的需求缺乏弹性，价格上升会使毒品市场的总收益增加，为了吸毒而抢劫行窃的瘾君子就会变多。 更好地做法是实行禁毒教育，使毒品的需求曲线左移，价格降低，数量减少，总收益也减少。 6. 第6章 供给、需求与政府政策 6.1. 价格控制 价格上限（price ceiling）：出售一种物品的法定最高价格 当价格上限大于平衡价格时，价格上限是非限制性的，对价格和销售量无影响。 当价格上限小于平衡价格时，价格上限对市场有一种限制性约束，需求量将大于供给量，造成物品短缺。 租金控制法，一种极无效率的帮助穷人提高生活水平的方法。更好的政策是租金补贴。 价格下限（price floor）：出售一种物品的法定最低价格 当价格下限小于平衡价格时，价格下限是非限制性的，对价格和销售量无影响。 当价格下限大于平衡价格时，价格上限对市场有一种限制性约束，供给量将大于需求量，造成物品过剩。 最低工资法，造成劳动供给量大于需求量，结果是出现失业。更好的政策是劳动收入税收减免。 6.2. 税收 税收归宿（tax incidence）：税收负担在市场参与者之间进行分配的方式。 1. 向卖者征税如何影响市场结果 三步走： 确定影响的是需求曲线还是供给曲线：征税使卖家获利能力减少，使供给曲线移动 确定曲线移动方向：征税提高了生产和销售的成本，减少了每一种价格下的供给量，供给曲线左移 考察这种移动如何影响均衡价格和数量：均衡价格上升，均衡数量减少。 结论：税收抑制了市场活动，且买者与卖者分摊了税收负担。 2. 向买者征税如何影响市场结果 三步走： 向买者征税影响了需求曲线 征税使人们不愿买，每种价格下需要的数量变少，需求曲线左移 均衡价格下降，均衡数量减少（虽然市场价格降低，但加上税收负担有效价格还是提高了） 结论：税收抑制了市场活动，且买者与卖者分摊了税收负担。 结合弹性的结论是：税收负担更多地落在缺乏弹性的市场一方身上。 7. 第7章 消费者、生产者与市场效率 福利经济学（welfare ecomomics）：研究资源配置如何影响经济福利的一门学问。 市场上的供求均衡可以最大化买者和卖者得到的总利益。 7.1. 消费者剩余 支付意愿（willingness to pay）：买者愿意为某种物品支付的最高量。 消费者剩余（consumer surplus）：买者愿意为一种物品支付的量减去其为此实际支付的量。 需求曲线以下和价格以上的面积衡量一个市场上的消费者剩余。 7.2. 生产者剩余 成本（cost）：卖者为了生产一种物品而必须放弃的所有东西的价值。 生产者剩余（producer surplus）：卖者出售一种物品得到的量减去其生产成本。 \u001c价格之下和供给曲线以上的面积衡量一个市场上的生产者剩余。 7.3. 市场效率 市场总剩余 = （买者的评价 - 买者支付的量）+（卖者得到的量 - 卖者的成本）= 买者的评价 - 卖者的成本 效率（efficiency）：资源配置使社会所有成员得到的总剩余最大化的性质。（蛋糕是否做大了） 平等（equality）：在社会成员中平均地分配经济成果的性质。（蛋糕是否分匀了） 均衡的结果是资源的有效配置，因此，自由市场是组织经济活动的最好方法。 7.4. 市场效率与市场失灵 市场势力会使市场无效率，使价格和数量背离供求平衡（如垄断） 外部性使市场福利不仅仅取决于买者的评价和卖者的成本（如污染） 8. 第8章 应用：赋税的代价 8.1. 赋税的无谓损失 无谓损失（deadweught loss）：市场扭曲（例如税收）引起的总剩余减少。 例子：Zander 为 Pig 打扫房间，每周得到100块，Zander 的时间成本是80块，Pig 对打扫房间的支付意愿是120。所以，Zander 和 Pig 从他们的交易中各得到20的利益，40块就衡量了这一交易的好处。 但如果政府对 Pig 征税50，Pig 能为打扫房间提供的最高价格就是120-50=70，这小于 Zander 的成本80，Zander 不干了，Pig 也成了真的 pig。40块就被称为赋税的无谓损失。 买者和卖者因税收遭受的损失大于政府筹集到的的税收收入。原因是税收扭曲了激励，买者不愿意消费了，卖者不愿意生产了，就引起了市场配置资源时的无效率。 8.2. 决定无谓损失的因素 供给和需求的弹性越大，税收的无谓损失也就越大。 8.3. 税收变动时的无谓损失和税收收入 随着税收规模的扩大，无谓损失迅速增加，税收收入会先随着税收规模增大而增大，但当税收规模的进一步增大，市场收缩也非常大（税太高，人们不进行交易），以至于税收收入开始减少。 拉弗曲线 紧紧盯住税率并不能计算出税收变动会使政府收入增加或减少多少，后者还取决于税收变动如何影响人们的行为。 9. 第9章 应用：国际贸易 9.1. 决定贸易的因素 世界价格（world price）：一种物品在世界市场上通行的价格。 一个国家的物品是出口还是进口取决于和世界价格的比较：世界价格高于国内价格——出口，世界价格低于国内价格——进口。（比较优势的体现） 9.2. 贸易的赢家和输家 1. 出口国的得失 出口国开放国际贸易后，国内价格上升到世界价格，国内的生产者状况变好，但消费者必须以更高的价格购买。 生产者收益超过了消费者损失，贸易使一国的经济福利整体增加。 2. 进口国的得失 进口国开放国际贸易后，国内价格下降到世界价格，国内的消费者状况变好，但生产者不得不以更低的价格出售物品。 消费者收益超过了生产者损失，贸易使一国的经济福利整体增加。 3. 关税的影响 关税（tariff）：对在国外生产而在国内销售的物品征收的一种税。 关税减少了进口量，并使国内市场向没有贸易时的均衡移动。（价格增加，供给量增加，需求量减少）国内生产者的状况变好了，政府筹集到了收入，但消费者的损失大于这些好处（激励的作用）。 进口配额和关税的结果很相似，但前者是为得到进口许可证的人创造了利益。 4. 国际贸易的其他影响 增加了物品的多样性 通过规模经济降低了成本 增加了竞争，避免了市场势力的产生 加强了思想交流 9.3. 各种限制贸易的观点 1. 工作岗位论 该观点认为自由贸易流失了生产者的岗位。 非也，每个国家的工人最终都会在该国有比较优势的行业中找到工作岗位。 如果这个世界由于让你忍受贸易的负面影响而对你有所亏欠，那么你是否也因享受了贸易的正面影响而亏欠整个世界呢？ ——Steven E. Landsburg 2. 国家安全论 当国家安全论的观点是由行业代表而不是国防机构提出时，就应该谨慎看待。 3. 幼稚产业论 该观点认为，应实行暂时性贸易限制，以有助于该新产业的成长，老产业也认为可以有助于其对新情况作出调整。 非也，政府要确定哪个产业实施这种保护最终是有利可图的，难以实施，而且历史表明初创企业的亏损一般只是暂时的，优胜略汰才是竞争本质。 4. 不公平竟争论 该观点认为，只有各国都按照同样的规则行事，自由贸易才是合意的，否则就是不公平竞争。 5. 作为讨价还价筹码的保护论 当与自己的贸易伙伴讨价还价时，贸易限制派上了用场：贸易限制威胁。但这种外交策略的成本是庞大的。 10. 第10章 外部性 外部性（externality）：一个人的行为对旁观者福利的无补偿的影响。如果对旁观者的影响是不利的，称为负外部性，有利的则是正外部性。 外部性的例子： 汽车尾气的负外部性 修复历史建筑物的正外部性 狂吠的狗的负外部性 新技术研究的正外部性 10.1. 外部性和市场无效率 1. 负外部性 在存在负外部性时，物品的社会成本大于其私人成本。 解决方法： 外部性内在化（internalizing the externality）：改变激励，以使人们考虑到自己行为的外部效应。 如生产铝造成了污染排放，政府对铝生产者销售的每吨铝征税，使供给曲线上移。 2. 正外部性 在存在正外部性时，物品的社会价值大于其私人价值。 政府需要尽量补贴正外部性，如教育。 负外部性使市场生产的数量大于社会合意的数量，正外部性使市场生产的数量小于社会合意的数量。 专利通过赋予企业对其发明的产权来使外部性内在化，对于企业从事推动技术进步的研究和其他活动提供了更多的激励。 10.2. 针对外部性的公共政策 政府可以通过两种方式对外部性导致的市场无效率作出反应：命令与控制政策直接对行为进行管制；以市场为基础的政策提供激励。 命令与控制政策：管制 以市场为基础的政策1:矫正税与补贴 矫正税（corrective taxes）：旨在引导私人决策者考虑负外部性引起的社会成本的税收，也称庇古税。 矫正税既增加了政府的收入又提高了经济效率&#x1F44D;，比如汽油税消除了开车造成的拥堵、车祸、污染三个负外部性。 市场为基础的政策2:可交易的污染许可证 矫正税通过污染的价格限制了污染的量，而污染许可证通过确定的污染了决定污染的价格。 10.3. 外部性的私人解决方法 私人解决方法的类型： 道德规范和社会约束 慈善行为 依靠有关各方的利己（多种类型经营） 利益各方签订条约 科斯定理（Coase theorem）：如果私人各方可以无成本地就资源配置进行协商，那么，他们就可以自己解决外部性问题。 私人经济主体可以解决他们之间的外部性问题，无论最初的权利如何分配，有关各方总可以达成一种协议，在这种协议中，每个人的状况都可以变好，而且，结果是有效率的。 交易成本（transaction cost）：各方在达成协议与遵守协议过程中所发生的成本。 11. 第11章 公共物品和公共资源 当一种物品没有价格时，私人市场不能保证该物品生产和消费的数量是适当的。在这种情况下，政府政策可以潜在地解决市场失灵问题。 11.1. 不同类型的物品 物品的特点： 是否具有排他性 排他性（excludability）：一种物品具有的可以阻止一个人使用该物品的特性。 是否具有消费中的竞争性 消费中的竞争性（rivalry in consumption）：一个人使用一种物品将减少其他人对该物品的使用的特性。 具有消费中的竞争性 不具有消费中的竞争性 具有排他性 私人物品（冰淇淋、衣服、拥挤的收费道路） 俱乐部物品（消防、有线电视、不拥挤的收费道路） 不具有排他性 公共资源（海洋中的鱼、环境、拥挤的不收费道路） 公共物品（龙卷风警报器、国防、不拥挤的不收费道路） 私人物品（private goods）：既有排他性又有消费竞争性的物品。 公共物品（public goods）：既无排他性又无消费竞争性的物品。 公共资源（common resources）：有消费竞争性但无排他性的物品。 俱乐部物品（club goods）：有排他性但无消费竞争性的物品。 11.2. 公共物品 搭便车者（free rider）：得到一种物品的利益但避免为此付费的人。 由于公共物品没有排他性，搭便车者的问题使得私人市场无法提供公共物品。但是政府可以潜在的解决这个问题：政府确信一种公共物品的总利益大于成本，它就可以提供该物品，并用税收收入进行支付，从而使每个人的状况变好。 国防 基础研究 反贫困 成本——收益分析（cost-benefit analysis）：比较提供一种公共物品的社会成本与社会受益的研究。 11.3. 公共资源 公地悲剧（Tragedy of the Commons）：一个说明从整个社会的角度看，为什么公共资源的使用大于合意的水平的寓言。 当一个人使用公共资源时，他就减少了其他人对这种资源的享用。 清洁的空气和水 拥堵的道路 鱼、鲸和其它野生动物 12. 第12章 税制的设计 “在这个世界上除了死亡和税收以外，没有什么事情是确定无疑的。”——本 富兰克林 美国联邦政府最大的收入来源是个人所得税、工薪税和公司所得税。最大的支出项是收入保障，如社会保障、事业保障等，其次是医疗项目、国防等。 预算赤字（budget deficit）：政府支出大于政府收入。 预算盈余（budget surplus）：政府收入大于政府支出。 税收制度的主要目标是筹集政府收入，当在许多不同的税制方案中选择时，决策者有两个目标：效率和平等。 12.1. 税收和效率 当税收扭曲了人们做出的决策时引起的无谓损失 纳税人在遵照税法纳税时承担的管理负担 一种有效率的税制要求是这两点的影响都尽可能小。 无谓损失是当人们根据税收的激励做出的反应，而不是根据买卖的物品与服务的真实成本。 增值税类似于零售税，但不是在消费者购买最终物品时的零售环节取得全部税收，而是在物品生产的各个阶段（即在企业增加了该物品价值的各个生产环节）取得税收。 平均税率（average tax rate）：支付的总税收除以总收入。 边际税率（marginal tax rate）：增加1美元收入所支付的额外税收。 如政府规定对第一个5万元的收入征收20%的税，对全部收入中超过5万元的部门征收50%的税。这种税收下，如果一个人收入为6万元，则会征收1.5万元的税（5*20%+1*50%），那么他的平均税率是1.5万/6万=25%，但边际税率是50%，因为他的收入再增加1元，税率都是50%。 定额税（lump-sum tax）：对每个人等量征收的税收。 不采用定额税的原因在于其只考虑到了税制的一个目标——效率，而没有考虑到平等。 12.2. 税收与平等 受益原则（benefits principle）：认为人们应该根据他们从政府服务中的得到的利益来纳税的思想。 支付能力原则（ability-to-pay principle）：认为应该根据一个人可以承受的负担来对这个人征税的思想。 纵向平等（vertical equity）：主张支付能力更强的纳税人应该缴纳更多税收的思想。 横向平等（horizontal equity）：主张有相似支付能力的纳税人应该缴纳等量税收的思想。 比例税（proportional tax）：高收入纳税人和低收入纳税人缴纳收入中相同比例的税收。 累退税（regressive tax）：高收入纳税人缴纳的税收在收入中的比例低于低收入纳税人的这一比例。 累进税（proggressive tax）：高收入纳税人缴纳的税收在收入中的比例高于低收入纳税人的这一比例。 13. 第13章 生产成本 产业组织研究企业有关价格和数量的的决策如何取决于他们所面临的市场条件。 13.1. 什么是成本 企业的目标是利润最大化。 总收益（total revenue）：企业出售其产品所得到的货币量。 总成本（total cost）：企业用于生产的投入品的市场价值。 利润（profit）：总收益减去总成本。 企业总成本的衡量角度： 1. 作为机会成本的成本 显性成本（explicit costs）：需要企业支出货币的投入成本。 如购买原材料的钱、支付给工人额度工资等。 隐形成本（implicit costs）：不需要企业支出货币的投入成本。 时间成本等。 经济学家关注于研究企业如何做出生产和定价决策，因此关注显性成本和隐形成本，如 Zander 做程序员赚的钱比经营糕点生意赚的多，他就会选择关闭工厂，成为一个全职程序员；而会计师往往只衡量显性成本，忽略隐形成本，时间成本不会出现在财务报表上。 2. 作为一种机会成本的资本成本 几乎每一个企业都有一项重要的隐形成本——已经投资于企业的金融资本的机会成本。 如 Zander 用储蓄的30w美元从前一个所有者那里购买了糕点厂，但如果他把这笔钱存入利率为5%的储蓄账户，那他每年将获得1.5w美元，因此，为了拥有糕点厂 Zander 放弃了每年1.5w美元的利息收入，这1.5w美元就是企业的隐形成本之一。 经济利润（economic profit）：总收益减总成本，包括显性成本和隐形成本。（经济学家衡量企业利润的方式） 会计利润（counting profit）：总收益减总显性成本。（会计衡量企业利润的方式） 经济利润是企业供给物品和服务的动机所在。获得正经济利润的企业才会继续经营，否则其最终将关闭企业并推出该行业。 13.2. 生产与成本 生产函数（production function）：用于生产一种物品的投入量与该物品产量之间的关系。 边际产量（marginal product）：增加一单位投入所引起的产量增加。 边际产量递减（diminishing marginal product）：一种投入的边际产量随着投入量增加而减少的特征。 生产函数的斜率衡量一个工人的边际产量。 13.3. 成本的各种衡量指标 1. 固定成本与可变成本 固定成本（fixed costs）：不随着产量变动的成本。 如租金、员工薪水 可变成本（variable costs）：随着产量变动而变动的成本。 如原材料的成本、为了生产而必须多雇人时的员工薪水 2. 平均成本与边际成本 平均总成本（average total cost）：总成本除以产量 平均固定成本（average fixed cost）：固定成本除以产量 平均可变成本（average variable cost）：可变成本除以产量 边际成本（marginal cost）：额外一单位产量所引起的总成本的增加 边际成本 = 总成本变动量 / 产量变动量 平均总成本告诉我们，如果总成本在所生产的所有单位中平均分摊，普通一单位产品的成本。边际成本告诉我们，多生产一单位产品引起的总成本增加。 有效规模（efficient scale）：使平均总成本最小的产量。 边际成本和平均总成本的关系： 只要边际成本小于平均总成本，平均总成本就下降；只要边际成本大于平均总成本，平均总成本就上升。 平均成本就像你的累计平均绩点，边际成本就像你下一门课将获得的成绩，如果你下一门课的成绩小于你的平均绩点，你的平均绩点就会下降；如果你下一门课的成绩大于你的平均绩点，你的平均绩点就会上升。 边际成本曲线与平均总成本曲线在平均总成本曲线的最低点处相交。 13.4. 短期成本与长期成本 对于许多企业来说，总成本在固定成本和可变成本之间的划分取决于时间范围。因为在长期中，企业可以选择自己想要的短期成本曲线，但在短期中，它不得不用它拥有的那一条短期成本曲线。 规模经济（economies of scale）：长期平均总成本随产量增加而减少的特性。 规模不经济（diseconomies of scale）：长期平均总成本随产量增加而增加的特性。 规模收益不变（constant returns to scale）：长期平均总成本在产量变动时保持不变的特性。 规模经济的产生，是因为较高的产量水平允许在工人中实现专业化，而专业化可以使工人更精通某一项工作。 规模不经济的产生可能由于任何一个大型组织中固有的协调问题。 “样样通，样样松”，一个努力去做每一件事的人，通常以什么也做不好而告终，如果一个企业想要自己的工人生产率尽可能的高，通常最好是让他们每一个人都从事自己所精通的有限工作。但只有这一个企业雇用大量工人，并生产大量产品时，这种工作的组织才是可能的。 14. 第14章 竞争市场上的企业 如果每个买者和卖者与市场规模相比都微不足道，从而没有什么能力影响市场价格，那么该市场就是竞争性的。与此相反，如果一个企业可以影响他出售的物品的市场价格，就说明该企业有市场势力。 14.1. 什么是竞争市场 竞争市场（competitive market）：有许多交易相同产品的买者与卖者，以至于每一个买者与卖者都是价格接受者的市场。 两个特征： 市场上有许多买者和许多卖者 各个买者提供的物品大体上是相同的 这两个特征导致的结果是，市场上任何一个买者和卖者的行为，对市场价格的影响都可以忽略不计。每一个买者和卖者都把市场价格作为既定的。 还有一个条件通常也是完全竞争市场的特征： 企业可以自由地进入或者退出市场 竞争市场中的企业与经济中大多数其他企业一样，目的是努力使利润（总收益减去总成本）最大化。 平均收益（average revenue）：总收益除以销售量。 对所有企业而言，平均收益等于物品的价格。 边际收益（marginal revenue）：增加一单位销售量引起的总收益变动。 对竞争企业而言，边际收益等于物品的价格。 14.2. 利润最大化与竞争企业的供给曲线 对于一个竞争企业来说，企业产品的价格既等于其平均收益，又等于其边际收益。 利润最大化的三个一般性规律： 如果边际收益大于边际成本，企业应该增加其产量。 如果边际成本大于边际收益，企业应该减少其产量。 在利润最大化的产量水平时，边际收益和边际成本正好相等。 在本质上，由于企业的边际成本曲线决定了企业在任何一种价格时愿意供给的物品数量，因此边际成本曲线也是竞争企业的供给曲线。 企业的短期停止营业决策 停止营业指由于当前的市场条件，而在某个特定时期时不生产任何东西的短期决策。 退出指离开市场的长期决策 区别是暂时停止营业的企业仍然必须支付固定成本（沉没成本），而退出市场的企业既不需要支付可变成本又不需要支付固定成本。 如果生产能得到的收益小于生产的可变成本，企业就停止营业。也就是说，如果物品的价格低于生产的平均可变成本，企业就选择停止营业。 竞争企业的短期供给曲线是边际成本曲线位于平均可变成本曲线之上的那一部分。 沉没成本（sunk cost）：已经发生而且无法收回的成本。 因为沉没成本无法赎回，所以当你做出包括经营战略在内的各种生活决策时可以不考虑沉没成本。 例如生意冷清的餐馆，餐馆老板必须记住固定成本与可变成本的区别。餐馆的许多成本如租金、厨房设备、桌子、盘子的都是固定的，停止营业并不能减少这些成本，只有增加的食物价格和增加的店员工资等这些可变成本才是与决策相关的，只有从吃午餐的顾客那里得到的收入少到不能弥补餐馆的可变成本时，老板才会在午餐时间关门。 企业退出或进入一个市场的长期决策 如果从生产中得到的收益小于它的总成本，企业就应退出市场。也就是说，如果物品的价格小于生产的平均总成本，企业就选择退出。 竞争企业的长期供给曲线是边际成本曲线位于平均总成本曲线之上的那一部分。 14.3. 竞争市场的供给曲线 讨论市场的供给需要考虑两种情况： 考察有固定数量企业的市场（短期） 考察企业数量会随老企业退出和新企业进入而变动的市场（长期） 1. 短期：有固定数量企业的市场供给 在任一种既定价格时，每个企业供给使其边际成本等于价格的产量，也就是说，只要价格高于平均可变成本，每个企业的边际成本曲线就是其供给曲线。 2. 长期：有进入与退出的市场供给 进入与退出这种类型市场的决策，取决于现有企业所有者和可以开办新企业的企业家所面临的激励。 如果市场上的现有企业盈利，新企业就有进入市场的激励。但这种进入会增加企业数量，增加物品供给量，使得价格下降，利润减少。 在这种进入和退出过程结束时，仍然留在市场中的企业经济利润必定为零。 利润 = （P - ACT） Q，当且仅当物品的价格等于生产那种物品的平均总成本时，一个正在经营的企业才有零利润。*只有当价格与平均总成本被推向相等时，进入与退出过程才结束。 如果竞争企业利润为零，为什么他们还要留在市场上？ 利润等于总收益减总成本，而总成本包括企业的所有机会成本，具体来说，总成本包括企业所有者用于经营的时间和金钱成本。在零利润均衡时，企业的收益必须能够补偿所有者的上述机会成本。 例子：假设为了开办农场一个农民有投入100万美元。如果不这样做，他可以把钱存入银行赚取每年5万美元的利息，此外，他还必须放弃每年能赚到3万美元的另一份工作。这样，农民种地的总机会成本就时8万美元，即使他的利润为零，他从经营农场中得到的收益也弥补了他的机会成本。 原理：会计师只关注显性成本，而不关注隐形成本。 企业进入和退出使长期市场供给曲线是完全富有弹性的。也就是说，当物品需求增加时，长期的结果是企业数量和总供给量增加，而价格没有发生任何变化。 有两个原因使长期市场供给曲线可能向右上方倾斜： 一些用于生产的资源数量可能是有限的（如土地等） 不同企业可能有不同的成本（如时间的利用率等） \b由于企业在长期中比在短期中更容易进入和退出，所以长期供给曲线一般比短期供给期限更具弹性。 一个竞争企业通过选择使得B\\的数量来实现利润最大化 A. 平均总成本最低 B. 边际成本等于价格 C. 平均总成本等于价格 D. 边际成本等于平均总成本 一个竞争企业在利润最大化的产量水平时,边际收益和边际成本正好相等。由于一个竞争企业是价格接受者,所以,其产品的边际收益等于市场价格。对于任何一个既定价格来说,竞争企业可以通过观察价格与边际成本曲线的交点来找出利润最大化的产量。 15. 第15章 垄断 竞争企业是价格接受者，而垄断企业是价格决定者。 竞争企业接受市场给定的其产品的价格，并选择供给量，以使价格等于边际成本。而垄断者收取高于其边际成本的价格。 例如微软的 Windows 软件 一个垄断企业可以控制它出售的物品的价格，但由于高价格会减少其顾客的购买量，因此垄断利润并不是无限的。 15.1. 为什么会产生垄断 垄断企业（monopoly）：作为一种没有相近替代品的产品的唯一卖者的企业。 垄断产生的基本原因是进入壁垒——垄断企业能在其市场上保持唯一卖者的地位，是因为其它企业不能进入市场并与之竞争。进入壁垒的三个主要形成原因： 垄断资源：生产所需要的关键资源由单个企业所拥有 现实经济巨大的情况下，拥有这种情况的企业很少。 政府管制：政府给予单个企业排他性地生产某种物品或服务的权利 例如专利法和版权法。 生产流程：某个企业能以低于大量企业的成本生产产品 自然垄断(natural monopoly)：由于企业能以低于两个或更多企业的成本向整个市场供给一种物品或服务而产生的垄断。 例如供水 随着市场的扩大，一个自然垄断市场可能会变成一个更具竞争性的市场。 15.2. 垄断者如何做出成产与定价决策 竞争企业和垄断企业之间的关键差别在于垄断企业影响其产品价格的能力。 平均收益总是等于物品的价格，这一点对于垄断者和竞争企业都受用。 垄断者的边际收益总是小于其物品的价格。因为垄断者的需求曲线向下倾斜。 当垄断者增加它的销售数量时，总收益（P * Q）有两种效应： 产量效应：销售的数量增多了，即 Q 增大，从而可能增加总收益。 价格效应：价格下降了，即 P 降低，从而可能减少总收益。 竞争企业在市场价格时可以销售它想销售的任何数量。 当价格对收益的影响大于产量对收益的影响时，边际收益就是负的。 垄断者的利润最大化产量是由边际收益曲线和边际成本曲线的焦点决定的。 竞争企业市场与垄断企业市场之间的关键差别：在竞争市场上，价格等于边际成本；在垄断市场上，价格大于边际成本。 因为垄断企业是价格定制者，而不是价格接受者，因此垄断企业的供给曲线是没有意义的，所以它没有供给曲线。 当专利赋予一个企业销售一种药品的垄断权时，企业收取垄断价格，垄断价格大大高于生产这种药品的边际成本。当药品专利到期时，新企业进入市场，使市场具有竞争性。因此，价格从垄断价格下降到边际成本。 15.3. 垄断的福利代价 从企业所有者的角度看，高价格使垄断极为合意（赚取了利润），但从消费者的角度看是不合意的。 由于垄断引起的资源配置不同于竞争市场，所以其结果必然以某种方式使总经济福利没有达到最大化。 无谓损失 垄断者生产的产量小雨社会有效率的产量。且垄断定价使一些对双方有益的交易无法进行。 垄断者类似于一个私人收税者，由于垄断者通过收取高于边际成本的价格发挥其市场势力，他就相当于打入了一个类似于税收的锲子。和税收不同的是，政府得到了税收收入，而私人企业得到了垄断利润。 垄断利润是一种社会代价吗？ 垄断利润本身不代表经济蛋糕的规模变小了，而仅仅代表生产者的那一块变大了，消费者的那部分变小了。除非基于某种理由认为消费者比生产者更应得到市场剩余——否则垄断利润就不是一个社会问题。 15.4. 价格歧视 价格歧视(price discrimination)：以不同价格向不同顾客出售同一种物品的经营做法。 价格歧视只存在于垄断市场上，因为如果在竞争市场实行价格歧视，会导致顾客转向其它企业购买。 大多出版公司的经营策略就是价格歧视，在各地的销售价格不同。 价格歧视是利润最大化垄断者的一种理性策略 价格歧视要求能根据支付意愿划分顾客 某些市场力量会阻止企业实行价格歧视（套利） 价格歧视增加了垄断利润，否则企业就会选择对所有顾客收取同样的价格。 生活中价格歧视的例子： 电影票 许多电影院对儿童和老年人收取低于其他观众的价格。 飞机票价 飞机上的座位以许多不同的价格出售。 折扣券 许多公司在报纸、杂志或网上向公众提供折扣券。 财务援助 许多学院和大学对贫困学生提供财务援助。 数量折扣 数量折扣（批发价）通常是一种成功的价格折扣，因为随着购买量的增加，顾客对额外一单位商品的支付意愿降低了。 15.5. 针对垄断的公共政策 与竞争市场相比，垄断市场不能有效地配置资源。垄断者生产的产量小于社会合意的产量，而且收取的价格高于边际成本。政府决策者会从以下四种方式来应对垄断问题： 努力使垄断行业更有竞争性。 管制垄断者的行为 把一些私人垄断企业变为公共企业 不作为 1. 用反托拉斯法增强竞争 如可口可乐公司和百事可乐公司合并策略不可能被同意，微软在1994年收购 Intuit 公司也被政府阻止。 反托拉斯法是旨在遏制垄断势力的法律集成。 2. 管制 管制指的是政府约束垄断者的行为，比如不允许这些公司随意定价。 3. 公有制 政府不是管制由私人企业经营的自然垄断企业，而是自己经营自然垄断企业，如电话、供水、电力公司等。 4. 不作为 一些经济学家认为，政府通常最好不要去设法纠正垄断定价的无效率。 15.6. 垄断的普遍性 竞争 垄断 相似之处 企业目标 利润最大化 利润最大化 最大化原则 MR = MC MR = MC 短期中能赚到经济利润吗？ 能 能 不同之处 企业数量 许多 一家 边际收益 MR = P MR 价格 P = MC P > MC 能生产出是福利最大化的产量水平吗？ 能 不能 长期中能进入吗？ 能 不能 长期中能赚到经济利润吗？ 不能 能 有价格歧视的可能性吗？ 没有 有 16. 第16章 垄断竞争 16.1. 在垄断和完全竞争之间 当市场上很多企业提供相同的物品时，就出现了竞争；当市场上只有一家企业时，就出现了垄断。当很多行业介于完全竞争和垄断的极端情况之间的某个位置，称为“不完全竞争”。 寡头（oligopoly）：只有少数几个提供相似或相同产品的卖者的市场结构。 寡头市场上的每个企业在选择生产多少以及定价时不仅会考虑他的竞争者怎么做，还会考虑他的竞争者会对其决策如何作出反应。 垄断竞争（monopolistic competition）：存在许多出售相似但不同产品的企业的市场结构。 垄断竞争市场的特征： 许多买者 产品存在差别 自由进入和退出 如书籍市场、DVD市场、电脑游戏市场、餐馆、点心市场、衣服市场等。 16.2. 差别产品的竞争 垄断竞争企业遵循垄断者的利益最大化规律：选择生产边际收益等于边际成本的产量。 垄断竞争市场上的长期均衡： 与垄断市场一样，价格大于边际成本。因为利润最大化要求边际收益等于边际成本，并且向右下方倾斜的需求曲线使得边际收益小于价格 与竞争市场一样，价格等于平均总成本。因为自由进入和退出使经济利润为零 垄断竞争和完全竞争之间两个差别： 1. 生产能力过剩 与完全竞争企业不同，垄断竞争企业可以增加其产量并降低生产的平均总成本。 2. 高于边际成本的价格加成 垄断竞争企业在其平均总成本曲线向下的部分运营，因此，边际成本低于平均总成本。这样，在价格等于平均总成本时价格必定高于边际成本。 垄断竞争与社会福利 无效率的来源之一是高于边际成本的价格加成。垄断竞争存在垄断定价的正常的无谓损失。 新进入的垄断竞争企业的外部性： 产品多样化外部性 抢走业务外部性 16.3. 广告 广告是垄断竞争企业（以及某些寡头企业）的一个自然特征。当企业有销售差别产品并收取高于边际成本的价格时，每个企业都有激励以做广告的形式来吸引更多的买者购买自己的产品。企业总收益中有2%左右用于广告。 广告的批评者们认为： 企业做广告是为了操纵人们的爱好，是心理性的，而不是信息姓的。 广告抑制了竞争。 广告的辩护者们认为： 企业用广告向顾客传递信息 广告促进了竞争 广告使得新企业更容易进入 企业愿意用大量的钱来做广告，这本身就向消费者传递了一个所提供产品质量的广告。（消费者：这个东西都愿意花这么钱来请大明星做广告了那么他的质量大概率不会差） 有品牌的企业花的广告费更多，而且产品价格也更高。 在品牌上的观点： 平台向消费者提供了在购买前不易判断的产品质量信息。 品牌向企业提供了保持高质量的激励，因为企业有保持自己品牌声誉的财务利害关系 17. 第17章 寡头 寡头（oligopoly）只有少数几个卖者提供相似或相同产品的市场结构。 博弈论（game theory）研究在不同策略状况下人们如何行为的理论。 在作出自己的生产决策时，寡头市场的每一家企业都要考虑它的决策会如何影响市场上所有其他企业的生产决策。 17.1. 只有少数几个卖者的市场 寡头的关键特征是合作与利己之间的冲突。 勾结（collision）：一个市场上的企业之间就生产的产量或收取的价格达成的协议。 卡特尔（cartel）：联合起来行事的企业集团。 一旦形成了卡特尔，市场实际就是由一个垄断者提供服务。 反托拉斯法规定不允许公司之间就产品的固定价格进行协商。 纳什均衡（Nash equilibrium）：相互作用的经济主体在假设所有其他主体所选策略为既定的情况下选择他们自己最优策略的状态。 比如我假设我的竞争企业生产的数量为70时，我做出决定：我生产的数量应该是90才能赚到最多的钱。 当寡头企业单独地选择利润最大化的产量时，他们生产的产量大于垄断但小于竞争的产量水平。寡头价格低于垄断价格，但高于竞争价格（竞争价格等于边际成本）。 每个寡头在作出增加生产物品的决策时都需要考虑两个因素： 产量效应：由于价格高于边际成本，在现行价格时没多销售1单位物品将增加利润 价格效应：提高产量将增加总销售量，这就会降低物品的价格并减少所销售的所有其它物品的利润 随着寡头市场上卖者数量的增加，寡头市场就越来越像竞争市场。其价格接近于边际成本，生产量接近于对社会有效率的水平。 17.2. 合作经济学 囚徒困境（prisiners's dilemma）：两个被捕的囚徒之间的一种特殊“博弈”，说明为什么甚至在合作对双方都有利时，保持合作也是困难的。 囚徒困境： B坦白 B沉默 A坦白 A8年，B8年 A自由，B20年 A沉默 A20年，B自由 A1年，B1年 占优策略（dominant strategy）：无论其他参与者选择什么策略，对一个参与者都为最优的策略。 利己使寡头有违背协议的激励，难以维持低产量、高价格和垄断利润的合作性结果。 案例 OPEC 和世界石油市场 美国苏联军备竞赛 ||美国军备|美国裁军| |:-:|:-:|:-:| |苏联军备|苏联处于危险之中；美国处于危险之中|苏联安全并强大；美国处于危险之中并弱小| |苏联裁军|苏联处于危险之中并弱小；美国安全并强大|苏联安全；美国安全| 公共资源 只有在市场竞争时，看不见的手才能引导资源有效配置，而只有市场上的企业不能相互合作时，市场才是竞争的。 “一报还一报”的策略是多次囚徒困境下的最优惩罚策略。意思是参与者从合作开始，上一次博弈时另一个参与者怎么做自己这次就怎么做，对方上次违规，我下次就违规。 17.3. 针对寡头的公共政策 从整个社会的角度来看，寡头之间的合作是不合意的，它使得产量太低而价格太高。因此政府应努力使寡头企业竞争，而不是合作。 政府的决策：贸易限制和反托拉斯法。 反托拉斯法不止禁止竞争企业之间的价格勾结协议，也谴责一些影响并不明显的经营做法，如： 转售价格维持 掠夺性定价 即通过价格战的方式赶走竞争企业。 搭售 经典案例——1998年微软案，是否允许微软把他的浏览器与 Windows 操作系统捆绑销售。 18. 第18章 生产要素市场 抛出问题：为什么电脑程序员赚的钱比加油站服务员多？ 生产要素（factors of production）：用于生产物品与服务的投入。 劳动、土地和资本是三种最重要的生产要素。 18.1. 劳动的需求 与经济中其他的市场一样，劳动市场也是由供求力量支配的。但不同的是，劳动需求是一种派生需求，大多数劳动服务不是作为最终产品供消费者享用的，而是作为生产成本投入其他物品的生产中去的。 生产函数（production function）：用于生产一种物品的投入量与该物品产量之间的关系。 劳动的边际产量（marginal product og labor）：增加一单位劳动所引起的产量增加量。 边际产量递减（diminishing marginal product）：一单位投入的边际产量随着投入量增加而减少的性质。 边际产量值（value of the marginal product）：一种投入的边际产量乘以该产品的价格。 一个竞争性的、利润最大化企业所雇用的工人数要达到使劳动的边际产量值等于工资的那一点。 对一个竞争性的、利润最大化企业来说，边际产量值曲线也是劳动需求曲线。 总结：当一个竞争企业雇用的劳动达到边际产量值等于工资的那一点时，它的产量也就达到价格等于边际成本那一点。 引起劳动需求曲线移动的要素： 产品价格 技术变革 其他要素的供给 18.2. 劳动的供给 人们面临权衡取舍，当选择工作时就等于放弃了闲暇，放弃了闲暇就等于放弃了工作，也就放弃了这段时间工作能得到的工资。 什么引起劳动供给曲线移动： 只要人们改变他们在某一既定工资时想工作的量，供给曲线就会发生移动。 爱好变动 可供选择的机会改变 移民 18.3. 劳动市场的均衡 竞争市场上决定工资的两个因素： 工资会自发调整，使劳动的供求达到平衡 工资等于劳动的边际产量值 改变劳动供求的任何事件都必定使均衡工资和边际产量值等量变动，因为这两个量必定总是相等的。 劳动供给和劳动需求共同决定了均衡工资，并且，劳动供给曲线或劳动需求曲线的移动引起了均衡工资的变动。 18.4. 其它生产要素：土地和资本 资本（captal）：用于生产物品与服务的设备和建筑物。 劳动的需求理论同样适用于土地和资本。 劳动、土地和资本各自赚到了他们在生产过程中的边际贡献的价值。 当从银行账户上获得利息时，这种收入是经济中资本收入的一部分。 改变任何一种生产要素供给的事件会改变所有要素的收入。 19. 第19章 收入与歧视 19.1. 决定均衡工资的若干因素 补偿性工资差别（compensating differentail）：为抵消不同工作的非货币特性而产生的工资差别。 例：煤矿工人得到的工资高于其他有相似教育水平的工人；工厂中夜班工人工资高于白班工人工资。 资本的本质在于它是被生产出来的生产要素。 人力资本（human capital）：对人的投资的积累，如教育和在职培训。 企业——劳动需求者——愿意向教育水平高的工人支付更高的工资，因为受教育程度高的工人有着较高的边际生产率。 “无论成本如何，上大学仍然是重要的。” 决定工资的其他因素： 对于从事各种职业的人来说，天赋都是极为重要的 与能力密切相关的是努力 在工资的决定中，机遇也在起作用 企业把大学学历解释为能力的一种信号。 对于一些工人来说，其工资被设定在高于供求平衡的水平的原因： 最低工资法 工会的市场势力 工会（union）：与雇主谈判工资和工作条件的工人协会 效率工资（efficiency wages）：企业为了提高工人的生产率而支付的高于均衡工资的工资。 罢工（strike）：工会有组织地从企业撤出劳动。 19.2. 歧视经济学 工资差别的另一个来源是歧视。 歧视（discrimination）：对仅仅是种族、民族、性别、年龄或其他个人特征不同的相似个人提供不同的机会。 利润动机是消除歧视性工资的差别的强大力量。 竞争市场包含了一种自发矫正雇主歧视的方法。只关心利润的企业进入市场倾向于消除歧视性工资差别。只有在顾客愿意为维持歧视性做法进行支付或政府强制歧视时，竞争市场上的这种工资差别才能持续下去。 20. 第20章 收入不平等与贫困 对收入分配的讨论分三步进行： 确定社会中不平等的严重程度 考虑有关政府在改变收入分配中应该起什么作用的不同观点 讨论旨在帮助社会最贫困成员的各种公共政策 20.1. 不平等的衡量 贫困率（poverty rate）：家庭收入低于一个称为贫困县的绝对水平的人口百分比。 贫困线（poverty line）：由联邦政府根据每个家庭规模确定的一种收入绝对水平，低于这一水平的家庭被认为处于贫困状态。 贫困是一种影响所有人口群体的经济病症，有三个显著的事实（结论更针对于美国&#x1F1FA;&#x1F1F8;）： 贫困与种族有关 贫困与年龄相关 贫困与家庭结构相关 衡量不平等时还要考虑的问题，这些问题导致“数据”给出的结果并不是完全不存在偏差的： 1. 实物转移支付 以物品和服务而不是现金形式给予穷人的转移支付，比如食品券、住房补贴、医疗服务等。 2. 经济生命周期 人的一生中收入总在变动，人们能以借款和储蓄来平缓收入的生命周期变动，因此他们在任何一年的生活水平更多地依赖于一生的收入，而不是当年的收入。 3. 暂时收入与持久收入 20.2. 收入再分配的政治哲学 1. 功利主义（utilitarianism） 一种政治哲学，根据这种政治哲学，政府应该选择使社会上所有人总效用最大化的政策。 效用（utility）：衡量幸福或满足程度的指标。 效用是福利的衡量指标，并且，根据功利主义者的看法，他也是所有公共政策和私人行动的最终目标。 功利主义最终会导致社会失去激励作用。 2. 自由主义（liberalism） 一种政治哲学，根据这种政治哲学，政府应该选择被认为是公正的政策，这种公正要由一位在“无知面纱”背后的无偏见观察者来评价。 最大最小准则（maximin criterion）：一种主张，认为政府的目标应该是时社会上状况最差的人的福利最大化。 社会保险（social insurance）：旨在保护人们规避负面事件风险的政府政策。 3. 自由至上主义（libertarianism） 一种政治哲学，根据这种政治哲学，政府应该惩罚犯罪并实行资源的协议，但不应该进行收入再分配。 20.3. 减少贫困的政策 1. 最低工资法 2. 福利 福利指补贴贫困者收入的政府计划，如贫困家庭临时援助TANF、补充性保障收入SSI等。 3. 负所得税 向高收入家庭征税，并给低收入家庭补贴。如劳动所得税减免EITC政策。 4. 实物转移支付 直接向穷人提供提高生活水平所需的某些物品与服务。如食物、衣服、居住场所等。 累进税制使筹资变得困难，因为这扭曲了人们的行为。它鼓励纳税人减少纳税义务，而不是增加自己的税前收入。 21. 第21章 消费者选择理论 抛出问题： 所有需求曲线都向右下方倾斜吗？ 工资如何影响劳动供给？ 利率如何影响家庭储蓄？ 21.1. 预算约束：消费者能买得起什么 预算约束线：表示消费者在某种既定收入时能买得起的物品的各种组合。（权衡取舍） 预算约束线的斜率等于两种物品的相对价格——一种物品与另一种物品的价格之比。 21.2. 偏好：消费者想要什么 无差异曲线：一条表示给消费者带来相同满足程度的消费组合的曲线。 横轴纵轴依然是两种物品，向下倾斜的曲线，曲线越高（或者越靠右）表示对两种物品的偏好更大（消费者想要更多的物品）。 边际替代率（MRS）：消费者愿意以一种物品交换另一种物品的比率，即无差异曲线上某点的斜率。 无差异曲线的四个特征 1. 消费者对较高无差异曲线的偏好大于较低无差异曲线 2. 无差异曲线向右下方倾斜 3. 无差异曲线不相交 因为同一条曲线上的不同点让消费者满足的程度都相同，如果在不同曲线上，物品的价值不对等，不可能让消费者同样满足。 4. 无差异曲线凸向原点 消费者更愿意放弃他已经大量拥有的一种物品，比如我有10000个银色的Macbook，但只有1台深空灰色的，我需要放弃10个银色的换1个深空灰色的。 完全替代品：无差异曲线为直线的两种物品。 如5毛硬币和一块硬币的编辑替代值是不变的数——2。 完全互补品：无差异曲线为直角形的两种物品。 如适合左脚的鞋和适合右脚的鞋这两个物品，消费者只关心鞋的对数。 21.3. 最优化：消费者选择什么 消费者的预算约束线和多条无差异曲线中相切的那条上的切点为最优点，在这点上，符合消费者的预算并且是他最偏爱的物品数量。 消费者选择的两种物品组合要使边际替代率等于相对价格。 收入增加如何影响消费者的选择 收入增加使得预算约束线向外移动（能购买更多的物品了），也就可以达到更高的无差异曲线了。 正常物品：收入增加引起需求量增加的物品。 抵挡物品：收入增加引起需求量减少的物品。 世界上大多数物品都是正常物品，但也有抵挡物品，如坐公交汽车，有钱了可能拥有自己的汽车了，坐公交汽车的需求就少了。 价格变动如何影响消费者的选择 任何一种物品的价格下降都会使得预算约束线向外移动。 收入效应：当价格的某种变动使消费者移动到更高或更低无差异曲线时所引起的消费变动。 现在百事可乐便宜了，我的收入购买力就增加了，所以我可以买更多的披萨和更多的可乐。 替代效应：当价格的某种变动使消费者沿着一条既定的无差异曲线变动到有新边际替代率的一点时所引起的消费变动。 现在百事可乐便宜了，我放弃一个披萨可以买更多的可乐了，因为披萨相对来说更贵了，所以我要少买披萨多买可乐。 当这两种效应同时发挥效应时，可以得到一个结论：消费者肯定会多买百事可乐的，但是否会多买披萨是无法确定的。 收入效应是向更高无差异曲线移动所引起的消费变动；替代效应是沿着无差异曲线变动到有不同边际替代率的一点所引起的消费变动。 21.4. 三种应用 1. 所有的需求曲线都向右下方倾斜吗？ 一般来说，当一种物品价格上升时，人们对其的购买量减少，反映了需求曲线向右下方倾斜。 吉芬物品（Giffen good）：价格上升引起需求量增加的物品。 当收入效应大于替代效应时，消费者会更多地购买吉芬物品，导致需求曲线向右上方倾斜。 书中例子：比如土豆和肉，当土豆价格上升时，消费者相对来说变穷了，人们对自己生活水平下降的反应是削减奢侈品——肉，而去多买价格上升的土豆，是收入效应使得消费者想更多地购买土豆而少买肉，但这吉芬物品是极其罕见的。 2. 工资如何影响劳动供给 考虑收入效应和替代效应，工资增加时，如果替代效应大于收入效应，则增加工作减少闲暇；反之增加闲暇减少工作（因为生活状况变好了）。 典型的例子是中彩票，收入极大增加了，但减少了劳动供给（不用工作了）。 3. 利率如何影响家庭储蓄 当利率上升时，替代效应使得年老时消费得更多，年轻时消费得更少。收入效应使得现在的状况比过去改善了，所以倾向于享受更多消费，年轻时储蓄减少。 22. 第22章 微观经济学前沿 经济学前沿中的三个主题，说明了经济学家如何努力扩展他们对人类行为和社会的理解： 不对称信息经济学 政治经济学 行为经济学 22.1. 不对称信息 人们在获得与相互影响相关的知识上的差别被称为信息不对称。 隐蔽性行为：委托人、代理人及道德风险 道德风险：一个没有收到完全监督的人从事不诚实或不合意行为的倾向。 代理人：一个为另一个人（称为委托人）完成某种行为的人。 委托人：让另一个人（称为代理人）完成某种行为的人。 雇佣关系是经典的例子，雇主是委托人，工人是代理人。道德风险问题是工人在没有收到充分监督时责任心下降的现象。 雇主避免道德风险的方法： 更好的监督 高工资 延期支付（年终奖） 隐蔽性特征：逆向选择和次品问题 逆向选择：从无信息一方的角度看，无法观察到的特征组合变为不合意的倾向。 比如卖者对所出售物品的特征了解得比买者多的市场上产生的问题，买者要承担物品质量低的风险。也就是说，从无信息买者的角度看，所出售物品的“选择”可能是“”逆向的。 例子： 二手车市场 劳动市场 保险市场 发信号：有信息的一方向无信息的一方披露自己私人信息所采取的行为。 如企业打广告是在向潜在顾客发出他们有高质量产品的信号。 筛选：无信息的一方所采取的引起有信息的一方披露信息的行为。 如买二手车前要求经过汽车技师的检验。 22.2. 政治经济学 政治经济学：用经济学的分析方法研究政府。 康多赛投票悖论 多数原则没有产生可传递的社会谝好。 指民主的投票不一定是合理的，受投票顺序的影响。 阿罗不可能性定理 博达计算：让每一个选民对不同的选项做排序，排在最后的给1分，排在倒数第二的给2分，以此类推，总分最高的获胜。 阿罗的设想是在投票结果中有以下特征： 确定性：如果每个人对A的谝好都大于B，A获胜。 传递性：如果击败B，B击败C，那么A一定击败C。 不相关选择的独立性：任何两个结果A和B之间的排序不应取决于是否还存在某个第三种结果C。 没有独裁者：没有一个人总能获胜，无论其它每个人的谝好如何。 但是，阿罗从数学的角度证明了——没有一种投票制度能满足所有这些特征。 中值选民说了算 中值选民定理：一个数学结论，表明如果要选民沿着一条线选一个点，而且，每个选民都想选远离他最谝好的点最近的点，那么，多数原则将选出中值选民最谝好的点。 22.3. 行为经济学 行为经济学指经济学中将心理学的观点考虑进来的分支学科。 行为经济学认为人们不总是理性的，他们还具有以下特点： 人们过分自信 人们过分重视从现实生活中观察到的细枝末节 人们不愿改变自己的观念 经济模型并不意味着复制现实，只是要说明所涉及问题的本质，以有助于理解。 一个有趣的问题：为什么价格通常以0.99结尾？ 原因是左位偏差，买者对价格的最左边的数字是极为敏感的，这是一种对最左边位置的非理性关注。 人们也是前后不一致的，又是一个有趣的实验： 假设有一些枯燥的工作，如洗衣服、打扫房间等，有两个问题： 你偏好A（立即花50分钟做完这些事），还是B（明天花60分钟做这些事）？ 你偏好A（在90天内花50分钟做这些事），还是B（花60分钟在91天内做这些事）？ 大多数人会选择 B 和 A，但是对于问题2，如果当90天到来时允许你改变你的主意，又会面临问题1了，结合你的答案考虑，人们是不是前后不一致的。 Zander Hsueh            updated 2022-06-12 19:30:44 "},"Ops/Docker.html":{"url":"Ops/Docker.html","title":"Docker","keywords":"","body":" Docker1. Docker 简介1.1. Docker 理念1.2. Docker 和虚拟机的区别1.3. Dcoker 基本组成2. Docker 安装2.1. 配置阿里云镜像加速器2.2. Hello World2.3. Docker 底层原理3. Docker 常用命令3.1. 帮助命令3.2. 镜像命令3.3. 容器命令3.4. 其它重要命令4. Docker 镜像4.1. UnionFS4.2. 分层的镜像4.3. 为什么 Docker 要采用分层的结构？4.4. 镜像的特点4.5. Docker 镜像 commit 操作5. Docker 容器数据卷5.1. 在容器内添加数据卷5.2. 数据卷容器6. DockerFile6.1. DockerFile 构建过程解析6.2. DockerFile 保留字指令6.3. 案例7. Docker 常用安装7.1. 安装 mysql7.2. 安装 Nginx8. 本地镜像发布到阿里云8.1. 本地镜像发布到阿里云流程8.2. 镜像的生成方法8.3. 将本地镜像推送到阿里云 Docker 学习链接：Docker 核心技术（基础篇） 1. Docker 简介 一款产品从开发到上线，从操作系统到运行环境，再到应用配置。开发+运维之间的协作需要关心很多东西，这也是不得不面对的问题，特别是各种版本迭代后，不同版本环境的兼容，对运维人员都是考验。 Docker 对此提供了一个标准化的解决方案，不会出现“在我的机器上可以正常工作”的情况。 1.1. Docker 理念 Docker 基于 Go 语言开发，主要目标是 “Build，Ship and Run Any App，Angwhere”，即通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的 APP 及其运行环境能偶做到“一次封装，到处运行”。 Docker 映像即应用： 运行文档 配置环境 运行环境 运行依赖包 操作系统发行版 内核 解决了运行环境和配置问题软件容器，是方便做持续集成并有助于整体发布的虚拟化容器技术。 1.2. Docker 和虚拟机的区别 虚拟机的缺点： 资源占用多 冗余步骤多 启动慢 Docker 使用的是 Linux 容器（Linux Containers）虚拟化技术，它不是一个完整的操作系统，而是对进程进行隔离。有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。容器内只需要软件工作所需的库资源和设置。 传统虚拟机技术虚拟出的是一套硬件，在其上运行一个完整的操作系统，在该系统上再运行所需的应用进程。 Docker 容器内的应用进程直接运行于宿主的内核，容器没有自己的内核，而且也没有进行硬件虚拟，因此更为轻便。 每个容器之间相互隔离，每个容器有自己的文件系统，容器之间进程不会相互影响，能区分计算资源。 1.3. Dcoker 基本组成 镜像（image） 镜像就是一个只读的模板，可以用来创建 Docker 容器，一个景象可以创建很多容器。（类、构造函数的概念） 容器（container） Docker 利用容器独立运行一个或一组应用，容器是用镜像创建的运行实例。 它可以被启动、开始、停止和删除，每个容器都是相互隔离的、保证安全的平台。 可以把容器看作是一个简易版的 Linux 环境（包括 root 用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。 容器和镜像的区别是容器是可读可写的。 仓库（repository） 仓库是集中存放镜像文件的地方，仓库分为公开仓库和私有仓库两种形式，最大的公开仓库是 Docker Hub。 2. Docker 安装 Linux 中查看系统相关信息： $ uname -r Docker 有两个版本： Docker CE 社区版，免费 Docker EE 企业版 centOS8 安装 Docker CE： 添加并启用官方 Docker CE 存储库 $ sudo dnf config-manager --add-repo=https://download.docker.com/linux/centos/docker-ce.repo 列出可用的 docker-ce 软件包 $ dnf list doher-ce --showduplicates | sort -r 跳过损坏依赖包进行安装 $ sudo dnf install docker-ce --nobest 2.1. 配置阿里云镜像加速器 登录阿里云进入容器镜像服务 拿到形如这样的加速器地址： https://qxs22d7v.mirror.aliyuncs.com 配置服务器中 Docker 的配置文件： $ sudo mkdir /etc/docker $ sudo nano /etc/docker/daemon.json 粘贴配置内容： { \"registry-mirrors\": [\"https://qxs22d7v.mirror.aliyuncs.com\"] } 重启 Docker 服务 $ systemctl daemon-reload $ systemctl restart docker 2.2. Hello World 执行 $ docker run hello-world 命令后 Docker 做什么： 在本机寻找该镜像 有则以该镜像为模板生产容器并运行，没有则去 Docker Hub 上查找该镜像 Hub 上能找到则下载到本地，没有则返回错误查不到该镜像 2.3. Docker 底层原理 Docker 是一个 CS 结构系统，守护进程运行在主机上，然后通过 Socket 链接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。容器是一个运行时环境，就是集装箱。 为什么 Docker 比传统虚拟机更快： Docker 有着比虚拟机更少的抽象层，不需要 Hypervisor 实现硬件资源虚拟化，在 CPU、内存利用率上有着明显的优势。 Docker 利用的是宿主机的内核，而不需要 Guest OS。避免了引寻、加载操作系统内核等比较费时费资源的进程。 Docker 容器 虚拟机(VM) 操作系统 与宿主机共享 OS 宿主机 OS 上运行虚拟机 OS 存储大小 镜像小，便于存储与传输 镜像庞大（vmdk、vdi等） 运行性能 几乎无额外性能损失 操作系统额外的 CPU、内存消耗 移植性 轻便、灵活，适应于Linux 笨重，与虚拟化技术耦合度高 硬件亲和性 面向软件开发者 面向硬件运维者 部署速度 快速，秒级 较慢，10s以上 3. Docker 常用命令 3.1. 帮助命令 1. docker version 2. docker info Docker 详细信息。 3. docker --help 3.2. 镜像命令 docker images 列出本地主机上的镜像。 选项 说明 REPOSITORY 仓库镜像源 TAG 镜像标签 IMAGES ID 镜像ID CREATED 创建日期 SIZE 大小 Options： -a：列出本地所有镜像（含中间映像层） -q：只显示镜像 ID --digests：显示镜像的摘要信息 --no-trunc：显示完整的镜像信息 docker search 镜像名 在 Docker Hub 上查找镜像。 Options： -s 数量：只显示 Star 超过该数值的镜像 --no-trunc：显示完整的镜像描述 --automated：只列出 automated build 类型的镜像 docker pull 镜像名 下拉镜像。直接写镜像名默认下拉最新版本的镜像。 docker rmi 镜像名/ID 删除本机上的镜像。 删除多个： $ docker rmi -f 镜像名1:TAG 镜像名2:TAG 删除全部： $ docker rmi -f $(docker -qa) Options： -f：已存在运行的该镜像的容器时强制删除镜像 3.3. 容器命令 新建并启动容器 $ docker run [OPTIONS] IMAGE [COMMAND] [ARG...] OPTIONS： --name=\"容器名字\"：为容器指定一个名字 -d：后台运行容器，并返回容器 ID，即启动守护式容器 -i：以交互模式运行容器，通常与 -t 同时使用 -t：为容器重新分配一个伪输入终端，通常与 -i 同时使用 -P：随即端口映射 -p：指定端口映射，有以下四种形式： ip:hostPort : containerPort ip::containerPort hostPort:containerPort containerPort 例如启动一个 centos 容器： $ docker pull centos $ docker run -it -name=\"zander\" centos 列出当前所有正在运行的容器 $ docker ps [OPTIONS] 默认显示当前正在运行的容器。 OPTIONS: -l：显示上次运行的容器 -a：显示所有当前运行和历史运行的容器 -n 数字：显示最近n个创建的容器 -q：静默模式，只显示容器编号 --no-trunc：显示详细信息 退出容器 退出容器有两种方式： 1. exit 停止并退出容器。 2. ctrl+P+Q 容器不停止退出。 启动容器 $ docker start 容器ID/容器名 重启容器 $ docker restart 容器ID 停止容器 $ docker stop 容器ID 强制停止容器 $ docker kill 容器ID 删除已停止的容器 $ docker rm 容器ID 一次性删除多个容器： $ docker rm -f $(docker ps -a -q) 或 $ docker ps -a -q | xargs docker rm | xargs 意思为将第一个命令的结果作为第二个容器的参数执行之。 3.4. 其它重要命令 启动守护式容器 $ docker run -d 镜像名 指不进入交互模式，并且 docker ps 不显示该的容器。 原因是 Docker 容器后台运行，就必须有一个前台进程。如果容器运行的命令不是那些一直挂起的命令（如运行 top、tail），容器会自动退出。 这是 Docker 的运行机制问题，解决办法是将要运行的程序以前台进程的形式运行。 例子：守护式进程运行 centOS 容器： $ docker run -d centos /bin/sh -c \"while true;do echo hello zander;sleep 2;done\" 然后使用下面的查看容器日志命令可看到打印项，并且使用 docker ps 查看 centos 容器在运行中。 查看容器日志 $ docker logs -f -t --tail 容器ID OPTIONS： -t：加入时间戳 -f：跟随最新的日志打印 --tail 数字：显示最后n条 查看容器内运行的进程 $ docker top 容器ID 查看容器内部细节 $ docker inspect 容器ID 进入容器并进行命令行交互 进入容器内部： $ docker attach 容器ID 在容器外层执行命令，不进入容器交互模式： $ docker exec -t 容器ID command 例：docker exec -t 10bdadad ls -l /tmp 从容器内拷贝文件到主机上 $ docker cp 容器ID: 容器内文件路径 目的主机路径 4. Docker 镜像 镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件。它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。 4.1. UnionFS UnionFS（联合文件系统）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。 UnionFS 是 Docker 镜像的基础，镜像可以通过分层来继承，基于基础镜像（没有父镜像的镜像），可以制作各种具体的应用镜像。 4.2. 分层的镜像 Docker 镜像的最底层是 bootfs（boot file system），主要包含 bootloader 和kernel，前者用于引导加载 kernel，Linux 刚启动时会加载 bootfs。boot 加载完成后整个内核就都在内存中了，此时系统会卸载 bootfs。 在 bootfs 上层的是 rootfs（root file system），包含 Linux 中典型的 /dev，/proc，/bin，/etc 等标准目录和文件。rootfs 就是各种不同操作系统发行版，如 Ubuntu、centOS 等。 分层体现在使用 docker pull 时多个 Pull complete。 4.3. 为什么 Docker 要采用分层的结构？ 最大的好处——共享资源。 比如多个镜像都从相同的 base 镜像构建而来，那么宿主机中只需要保存一份 base 镜像，同时内存中也只需加载一份 base 镜像，就可为所有容器服务。 4.4. 镜像的特点 Docker 镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部，这一层就称为“容器层”，“容器层”之下的都是“镜像层”。 4.5. Docker 镜像 commit 操作 1. docker commit 提交容器副本使得其成为一个新的镜像，提交后可使用 $ docker images 查看。 2. docker commit -m=\"描述信息\" -a=\"作者\" 容器ID 要创建的目标镜像名:[标签名] 5. Docker 容器数据卷 容器运行之后产生的数据需要进行持久化存储，而不是容器停止或删除后数据丢失 容器之间可能共享数据 Docker 中容器数据卷由Docker挂载到容器，不属于联合文件系统，完全独立于容器的生存周期，作用： 数据持久化 容器间继承 + 共享数据 5.1. 在容器内添加数据卷 1. 通过命令添加 $ docker run -it -v /宿主机绝对路径目录:/容器内目录 镜像名 数据卷挂载成功后可通过 $ docker inspect 容器ID 命令查看详细信息，其内有数据卷的相关信息。 目录挂载成功后，容器内文件夹数据的读写可同步共享到宿主机内。 容器停止并退出，主机修改数据后重启容器，数据自动同步。 添加读写保护： $ docker run -it -v /宿主机绝对路径目录:/容器内目录:ro 镜像名 -ro 为 read only，表示容器内只读，而主机可以进行读写。 2. DockerFile 添加 宿主机的根目录下新建文件夹 mydocker 并进入 在 DockerFile 中使用 VOLUME 指令给镜像添加一个或多个数据卷 出于可移植和分享的考虑，不能在 DockerFile 中指定宿主机的目录，因为不能保证所有的宿主机上都存在这样的特定目录。 File 构建 FROM centos VOLUME [\"/dataVolumeContainer1\", \"/dataVolumeContainer2\"] CMD echo \"finished, -------success1\" CMD /bin/bash build 后生成镜像 $ docker build -f /mydocker/DockerFile -t zander/centos . run 容器 $ docker run -it zander/centos 容器内的容器卷已经存在，使用 $ docker inspect 容器id 查看宿主机上的 Volumes 默认绑定的宿主机路径 Dcoker 挂载的主机目录访问出现 cannot open directory .:Permission denied 问题解决办法：在docker run 命令的挂载目录后加 --privileged=true 参数。 5.2. 数据卷容器 命名的容器挂载数据卷，其它容器通过挂载这个（父容器）实现数据共享，挂载数据卷的容器就被称为数据卷容器。 先启动一个父容器 dc01，并在 dataVoluneContainer2 新增内容 $ docker run -it --name=dc01 zander/centos $ cd dataVolumeContainer2 $ touch dc01.txt dc02/dc03 继承自dc01，分别也创建相应的内容 $ docker run -it --name dc02 --volumes-from dc01 zander/centos 此时 dc01/dc02/dc03 的 /dataVolumeContainer2 中有 dc01.txt、dc02.txt/dc03.txt，即成功共享数据 删除容器 dc01 中的 dc01.txt，但容器dc02/dc03 中仍存在 结论：容器之间配置信息的传递，数据卷的生命周期一直持续到没有容器使用它为止（删除互不影响） 6. DockerFile DockerFile 是用来构建 Docker 镜像的构建文件，是由一系列命令和参数构成的脚本。 构建的三个主要步骤： 编写 DockerFile docker build docker run 6.1. DockerFile 构建过程解析 DockerFile 基础知识： 每条保留字指令都必须为大写字母且后面至少要跟随一个参数 指令按照从上到下，顺序执行 # 表示注释 每条指令都会创建一个新的镜像层，并对镜像进行提交 6.2. DockerFile 保留字指令 FROM 基础镜像，当前新镜像是基于哪个镜像的。 MAINTAINER 镜像维护者的姓名和邮箱地址。 RUN 容器构建时需要运行的命令。 EXPOSE 当前容器对外暴露的端口号。 WORKDIR 指定创建运行容器后，终端默认所在的工作路径。 ENV 用来在构建镜像过程中设置环境变量 ADD 将宿主机目录下的文件拷贝进镜像，且 ADD 命令会自动处理 URL 和解压 tar 压缩包。 COPY 类似 ADD，拷贝文件和目录到镜像中。将从构建上下文目录中的文件/目录复制到新的一层镜像内的位置。 VOLUME 容器数据卷，用于数据保存和持久化工作。 CMD 指定一个容器启动时要运行的命令。DockerFile 中可以有多个 CMD 指令，但只有最后一个生效，CMD 会被 docker run 之后的参数替换。 ENTRYPOINT 指定一个容器启动时要运行的命令。目的和 CMD 一样，都是在指定容器启动程序及参数。 docker run 之后的参数会被当作参数传递给 ENTRYPOINT，之后形成新的命令组合。 ONBUILD 当构建一个被继承的 DockerFile 时运行的命令，父镜像在被子继承后父镜像的 onbuild 被触发。 BUILD Both RUN FROM WORKDIR CMD MAINTAINER USER ENV COPY EXPOSE ADD VOLUME RUN ENTRYPOINT ONBUILD .dockerignore 6.3. 案例 docker run 官方 centos 镜像存在的问题： 进入口默认的路径是根目录 默认不支持 vim（因为是精简版centos） 默认不支持 ifconfig，原因同上 自定义 centos 编写 DockerFile FROM centos MAINTAINER zander ENV MYPATH /usr/local WORKDIR $MYPATH RUN yum -y install vim RUN yum -y net-tools EXPOSE 80 CMD echo $MYPATH CMD echo \"success\" CMD /bin/bash 构建镜像 $ docker build -f /mydocker/DockerFile2 -t mycentos:1.0 . 我的 centos 8 在运行时遇到了 Failed to download metadata for repo 'AppStream' 的错误，暂未解决&#x1F641; 运行容器 $ docker run -it mycentos 使用 $ docker history 镜像ID 可查看镜像构建详细步骤 ONBUILD 新建DcokerFile： FROM centos CMD [\"curl\",\"-s\",\"http://www.baidu.cn\"] ONBUILD RUN echo \"father is running-----------------success\" 创建父镜像 $ docker build -f /mydocker/DockerFile3 -t hello_father . 新建DockerFile，继承上方父镜像，构建子镜像 FROM myip_father CMD [\"curl\",\"-s\",\"http://www.baidu.cn\"] $ docker build -f /mydocker/DockerFile4 -t hello_son . 运行此命令时会触发父镜像中的 ONBUILD 项。 7. Docker 常用安装 7.1. 安装 mysql docker search mysql docker pull mysql 运行容器 $ docker run -p 12345:3306 --name zander/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql 7.2. 安装 Nginx [安装 NGINX(https://xuezenghui.com/posts/ecs-server/#%E5%AE%89%E8%A3%85-nginx) 8. 本地镜像发布到阿里云 8.1. 本地镜像发布到阿里云流程 8.2. 镜像的生成方法 DockerFile + docker build 从容器创建一个新的镜像 $ docker commit [OPTIONS] 容器ID [REPOSITORY[:TAG]] 8.3. 将本地镜像推送到阿里云 创建本地镜像 阿里云开发者平台 创建镜像仓库（代码源选择本地仓库） 点击管理按照步骤来 Zander Hsueh            updated 2022-06-12 18:35:50 "}}
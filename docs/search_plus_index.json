{"./":{"url":"./","title":"Introduction","keywords":"","body":" Zander's Notes Zander's Notes 欢迎来到我的学习笔记站点。 个人博客：xuezenghui.com Zander Hsueh            updated 2022-06-12 16:54:58 "},"Dev/":{"url":"Dev/","title":"Dev","keywords":"","body":" 开发 开发 Zander Hsueh            updated 2022-06-12 18:35:50 "},"Dev/MongoDB.html":{"url":"Dev/MongoDB.html","title":"Mongo DB","keywords":"","body":" MongoDB1. 主键2. 增2.1. 写入单个文档2.2. 写入多个文档3. 查3.1. 过滤数据3.2. 比较操作符3.3. 逻辑操作符3.4. 字段操作符3.5. 数组操作符3.6. 运算操作符3.7. 文档游标3.8. 分页函数3.9. 排序函数3.10. 统计函数4. 改4.1. 更新文档的方法4.2. 更新操作符5. 删6. 聚合操作6.1. $project6.2. $macth6.3. $limit 和 $skip6.4. $unwind6.5. $sort6.6. $lookup6.7. $group6.8. $out6.9. 聚合操作额外配置6.10. 聚合操作表达式6.11. 数据类型转换操作符7. 索引7.1. explain() 查询分析工具7.2. 复合索引7.3. 多键索引7.4. 索引对排序的影响7.5. 唯一索引7.6. 稀疏索引7.7. 索引生存时间7.8. 删除索引8. 数据模型8.1. 文档间关系9. Mongoose10. 复制集10.1. 复制集同步规则11. 分片11.1. 分片结构11.2. 分片片键11.3. 如何选择片键11.4. 分片查询 MongoDB 1. 主键 用于保证每一条数据的唯一性 自动添加，无需自行指定，主键名为 _id _id 是一个 ObjectId 类型的数据，即一个12个字节的字符串（4e5ade53-8cd45e-9de3-d943ae） 4子节是存储这条数据的时间戳 3字节是存储这条数据的电脑的标识符 2字节是存储这条数据的 MongoDB 进程 id 3字节是计数器 可保证数据库横向扩展后数据的唯一性。 2. 增 2.1. 写入单个文档 1. db..insertOne() 2. db..save() 两个方法的区别在于插入时如果主键重复，insertOne() 报错，插入失败，而 save() 会覆盖已存在的数据。 2.2. 写入多个文档 1.db..insertMany() 接收两个参数： 文档数组 可选的配置项对象，对象内可传入 ordered ，表示是否按顺序写入。默认为 true，前面的文档出错时后面的所有文档都不会被写入。设为 false 时，不按顺序写入，但写入效率较高，前面的文档出错，后面所有文档会被继续写入。 3. 查 3.1. 过滤数据 1. db..find(, ) query：查询的条件 projection：投影文档，规定查询的结果中显示哪些字段，默认都为1，不显示字段的设为 0 投影的条件不能同时包含 0 和 1（_id 不受限制），如不能为 db.getCollection('person').find({}, {age: 0, name: 1}); 3.2. 比较操作符 $eq：等于 $ne：不等于（不存在需要判断的字段也算作不等于） $gt：大于 $gte：大于等于 $lt：小于 $lte：小于等于 db..find({name: {$ne: \"Zander\"}}); $in：匹配和任意指定值相等的文档，值为数组 $nin：匹配和任意指定值都不相等的文档，值为数组（不存在需要判断的字段也满足条件） db..find({name: {$in: [\"Zander\", \"Paul\", \"Leon\"]}}); 3.3. 逻辑操作符 逻辑操作符后需为一个正则表达式或对象。 $not：非（不存在需要判断的字段也满足条件） $and：且 $or：或 $nor：都不（不存在需要判断的字段也满足条件） // 查询所有名字不为 Zander 的 db.person.find({name: {$not: {$eq: \"Zander\"}}}); // 且 db.person.find({$and: [{name: \"Zander\", age: 18}]}); // 或 db.person.find({$or: [{name: \"Zander\"}, {name: \"Hello\"}]}) // not or 都不 db.person.find({$nor: [{name: \"Zander\"}, {name: \"Hello\"}]}) 3.4. 字段操作符 $exists：查询包含某个字段的文档 可配合 $ne、$nin、$nor、$not 清理数据 db.person.find({name: {$ne: 'Zander', $exists: true}}) $type：查询指定字段包含指定类型的文档 db.person.find({age :{$type: 'number'}}) 3.5. 数组操作符 $all：匹配数组字段包含指定数组内所有元素的文档 db.getCollection('person').find({book: {$all: [\"a\", \"b\"]}}) $is：匹配数组字段中至少有一个元素符合多个查询条件的文档 db.getCollection('person').find({students: {$elemMatch: {name: \"Zander\", age: 18}}}) 3.6. 运算操作符 $regex：查询满足正则的文档 // 匹配 name 以 z/Z 开头的文档，i 表示忽略大小写 db.getCollection('person').find({name: {$regex: /^z/, $options: 'i'}}) // or db.getCollection('person').find({name: {$regex: /^z/i}}) 3.7. 文档游标 find() 方法的返回值是一个文档游标，相当于 C 语言的指针，文档游标的方法有： hasNext()：判断是否还有下一个文档 next()：取出下一个文档 forEach()：依次取出所有文档 3.8. 分页函数 cursor.limit()：取出文档的数量 cursor.skip()：跳过文档的数量 3.9. 排序函数 cursor.sort({field: ordering})：按照指定规则排序 ordering 为1表示升序，为-1表示降序 sort 和 limit/skip 同时使用时，无论 sort 写在前面还是后面都会先执行 sort。 3.10. 统计函数 count()：统计查询结果的数目 可接收一个 applySkipLimit 参数，表示统计数目时是否忽略 skip 和 limit，默认为 false，表示忽略 skip 和 limit 查询总数。 db.getCollection('person').find({}).limit(5).sort({age: 1}).count({applySkipLimit: true}) 4. 改 4.1. 更新文档的方法 1. db..save() 当没有指定 _id 字段时为新增，如果指定了已经存在的 _id 则覆盖原文档。 2. db..update(, , ) ：筛选条件 ：新的内容 ：配置项 默认会覆盖原文档，若要只更新，则需使用更新操作符。 默认只更新满足筛选条件的第一个文档，若要更新所有满足条件的文档需指定第三个参数 { multi: true}，同时在第二个参数中必须使用更新操作符 第二个参数中如果指定了 _id，则必须与原文档取值一致，否则报错无法更新（一般不指定 _id） 3. db..findAndModify() 4.2. 更新操作符 默认情况下 update 会直接覆盖旧文档，使用更新操作符可更新文档内特定的字段。 1. $set 更新或新增字段，字段存在则更新，不存在则新增。 db.getCollection('person').update({name: \"Tony\"}, {$set: {age: 99, book: \"her\"}}) 2. $unset 删除字段，字段的值无关紧要。 db.getCollection('person').update({name: \"Tony\"}, {$unset: {'age': \"\"}}) 如果删除的是数组字段中的元素，不会改变数组的长度，而是使用 null 替换删除的内容 3. $rename 重命名字段。 db.getCollection('person').update({name: \"Tony\"}, {$rename: {'name': \"first_name\"}}) 如果文档里已经存在新的名称，则会删除已经存在的字段 不能通过 $rename 来操作数组内对象的属性名 使用技巧： 可将内层文档中的字段转移到外层，或将外层转移到内层： db.getCollection('person').update({name: \"Tony\"}, {$rename: {'age': \"obj.age\"}}) 4. $inc 更新字段值（增加或减少字段的值），只能操作 Number 类型的字段。 db.getCollection('person').update({name: \"Tony\"}, {$inc: {'age': 2}}) db.getCollection('person').update({name: \"Tony\"}, {$inc: {'age': -5}}) 若不存在要操作的字段，则新增这个字段，初始值为0再执行增加/减少操作。 5. $mul 更新字段值（乘以或除以字段的值），只能操作 Number 类型的字段。 6. $min 更新值时保存较小的值。 db.getCollection('person').update({name: \"Zander\"}, {$min: {'age': 1}}) 如果要操作的字段不存在，则自动增加这个字段并将值赋给它。 6. $max 更新值时保存较大的值。 7. $addToSet 向数组字段中添加元素。 db.getCollection('person').update({name: \"Zander\"}, {$addToSet: {\"book\": \"金瓶梅\"}}) 如果要操作的字段不存在，则自动增加这个数组字段并向数组中添加元素。 添加的元素会自动去重。 8. $push 向数组字段中添加元素（不去重）。 9. $pop 从数组中删除元素，传1表示删除最后一个元素，传-1表示删除第一个元素。 db.getCollection('person').update({name: \"Zander\"}, {$pop: {\"book_name\": -1}}) 10. $pull 从数组中删除指定的元素，可以指定具体的值或正则表达式。 db.getCollection('person').update({name: \"Zander\"}, {$pull: {\"book_name\": \"123\"}}) // 指定元素的值 db.getCollection('person').update({name: \"Zander\"}, {$pull: {\"book_name\": /^1/}}) // 指定正则表达式 如果要删除的数组内的元素是 Object 类型，只要匹配到一个属性就可删除整个对象。 11. $pullAll 从数组中批量删除特定元素。 db.getCollection('person').update({name: \"Dom\"}, {$pullAll: {book: [\"三国\", \"西游\"]}}) 如果要删除的数组内的元素是 Array 类型或者 Object 类型，元素的顺序和值必须一摸一样才可删除。 12. $和$[] $：更新数组中满足条件的特定元素 db.getCollection('person').update({name: \"Dom\", \"book.name\": \"西游\"}, {$set: {\"book.$.name\": \"水浒\"}}) // 更新数组中对象的属性值 $[]：更新数组中所有元素 db.getCollection('person').update({name: \"Zander\"}, {$set: {\"book_name.$[]\": \"水浒\"}}) 5. 删 1. 删除所有满足条件的数据 db.getCollection('person').remove({name: \"Zander\"}) 2. 删除满足条件的第一条数据 db.getCollection('person').remove({name: \"Zander\"}, {justOne: true}) 6. 聚合操作 聚合操作就是通过一个方法完成一系列的方法，聚合中的每一个操作成为一个阶段，上一阶段会将处理的结果传给下一个阶段继续处理。 6.1. $project 作用：对输入的文档进行再次投影，按照需要的格式生成结果 格式：{$project: { field: value }} 如果在 $project 操作中使用了原文档中不存在的字段则自动添加，使用 null 填充。 db.getCollection('person').aggregate([ { $project: { _id: 0, my_name: \"$name\" } } ]) 6.2. $macth 作用：用于筛选符合条件的文档 格式：{$match:{ field: value }} 6.3. $limit 和 $skip 1. $limit 作用：用于指定获取的文档数目 格式：{$limit: } 2. $skip 作用：用于指定跳过的文档数目 格式：{$skip: } 6.4. $unwind 作用：展开数组字段 格式：$unwind: {path: } 参数： includeArrayIndex: 'index'：在结果中添加数组的索引 preserveNullAndEmptyArrays: true：空数组和 null 也拆分 6.5. $sort 作用：排序 格式：$sort: {} 6.6. $lookup 作用：关联查询 格式： 关联形式： {$lookup: { form: localField: foreignField: as: } } 不关联形式： {$lookup: { form: let: { 定义给关联集合的聚合操作使用的当前集合的常量 } pipeline: [关联集合中的聚合操作] as: } } 6.7. $group 作用：对文档进行分组 格式： {$group: { _id: , : { }, ...: ... } } 6.8. $out 作用：将前面阶段处理完的文档写入一个新的集合 格式：{$out: } 若不存在这个集合，则自动创建；若已存在这个集合，则直接覆盖。 6.9. 聚合操作额外配置 db..aggregate(, ) 1. allowDiskUse: 管道阶段占用内存超过100M时允许写入数据到临时文件中。 6.10. 聚合操作表达式 1. 字段路径表达式 $：使用 $ 表示字段路径 {$project: { _id: 0, name: '$name' } } 2. 系统变量表达式 $$CURRENT：表示当前操作的文档 $$CURRENT.name === $name 3. 常量表达式（相当于转义） $literal: {$project: { _id: 0, name: {$literal: '$name'} } } 6.11. 数据类型转换操作符 作用：将不同的数据类型转换为相同的类型，便于后续处理，不是一个单独的管道阶段 格式： {$convert: { input: , to: , onError: , onNull: } } 7. 索引 用于提升数据的查询速度，相当于字段的目录。 主键会默认创建索引 获取索引：getIndexes() 创建索引：createIndex({ : 1 | -1 })，1表示正序，-1倒序 7.1. explain() 查询分析工具 db.getCollection('person').find({name: \"Zander\"}).explain() 依据 winningPlan 中的 stage 的取值来判断查询的方式： IXSCAN：根据索引查询 COLLSCAN：遍历整个集合查询 7.2. 复合索引 db.getCollection('person').createIndex({name: -1, age: -1}) 查询的时候只支持前缀查询（查询条件包含前缀），如上面的查询只支持使用 name 的索引查询，使用 age 查询时不会使用索引。 7.3. 多键索引 为数组字段创建索引时会为其每一个元素都创建索引。 7.4. 索引对排序的影响 排序的字段若不是索引字段，会在执行查询的时候排序再输出；反之，直接获取索引对应的文档来输出。 如果是符合索引，则排序条件包含索引字段的前缀字段才会使用索引来排序 7.5. 唯一索引 主键默认为唯一索引 创建唯一索引：指定参数 {unique: true} 若添加的字段没有唯一索引的字段，第一个这样的文档会自动填充null，第二个会报错 7.6. 稀疏索引 稀疏索引可优化索引占用的存储空间，添加参数 {sparse: true}。 稀疏性索引忽略不含有索引字段的文档，即如果索引具备唯一性且具备稀疏性，可添加缺失索引字段的文档 7.7. 索引生存时间 若文档包含日期字段或包含日期的数组字段，可在创建索引的时候指定索引的生存时间，超过生存时间会自动删除对应的文档。 ⚠️不能保证即时性。 db.getCollection('person').createIndex({addTime: 1}, {expireAfterSeconds: 5}) 若给数组字段指定了超时时间，则以数组中时间最小的值为基准计算超时时间。 7.8. 删除索引 db..dropIndex() 8. 数据模型 8.1. 文档间关系 内嵌式结构 一次查询就能得到所有数据 若数据比较复杂，不方便管理和更新 适用于数据不复杂/查询频率较高的场景 规范式结构：通过 id 关联 方便管理复杂的数据 查询数据相对麻烦 适用于数据复杂/更新频率较高的场景 关系的方式： 一对一 一对多 多对多 9. Mongoose 安装并导入 链接 MongoDB 监听链接状态 // 自调用函数返回 Promise (async () => { const result = await User.find({}); })(); 10. 复制集 如果所有数据都存储在一台 MongoDB 服务器上： 不具备高可用性，一旦服务器宕机，用户无法继续使用 不具备数据安全性，服务器损坏数据丢失 不能对数据进行分流（访问数据时远慢近快） 将多台保存了相同内容的 MongoDB 服务器组成一个集群，称为复制集。 在复制集中每一台 MongoDB 服务器都是一个节点。 在一个复制集中最多有50个节点。 在复制集中必须有一个主节点，只有主节点可以同时读写数据，其它副节点只能读数据。 复制集中节点之间每隔2秒相互发送心跳请求，检查是否有节点出现问题，若某个节点10s没有相应请求，视为出现问题。 主节点若出现问题，副节点自动发起投票，重新选举主节点。 触发选举的条件： 初始化复制集时 有新节点加入时 已有主节点挂了时 10.1. 复制集同步规则 初始化同步 当有一个新节点加入到复制集之后，会将所有主节点的数据拷贝到新节点中 同步写库记录 在每一个 MongoDB 服务器上都有一个 local 数据库，其中 oplog 集合保存当前服务器的所有操作记录。执行完初始化同步后，副节点会定期同步和执行写库记录 11. 分片 分片就是将数据库集合中的数据拆分成多份，分布式地保存到多台主机上，可解决服务器的容量问题。 并不是所有集合都需要做分片，不使用分片的集合统一保存在主分片中。 11.1. 分片结构 分片服务器：同于存储不同数据的多个服务器 配置服务器：用于配置分片服务器存储范围 路由服务器：负责分发客户端请求 路由服务器分发请求的流程： 客户端发送请求到路由服务器 路由服务器配置服务器查询数据段（数据范围） 根据查询的结果到对应的分片服务器上做处理 拿到处理结果，将处理的结果返回给用户 11.2. 分片片键 分片片键用于将数据存储到不用的分片服务器上。 可以将文档里的一个或多个字段设置为分片片键 设置完后，mongodb 会自动按照字段的取值进行划分，划分为一个个数据段 然后 mongodb 会自动决定哪个分片服务器保存哪些数据段 注意点： 片键可以一个或者多个字段 只有索引字段才能被设置为片键 分片服务器保存哪些数据段的值是随机的，并不是连续的 数据段的划分可以使用片键的取值，也可以使用片键取值的哈希值 11.3. 如何选择片键 片键字段取值范围应更广，以划分更多的数据段 字段取值的分配应更平衡，而不是都集中在某个数据段内 不应该选择单向增加或者减少的字段作为片键 技巧： 取值不够广或不够平衡，可使用复合片键 如果取值是单向增加/减少，可使用其哈希值划分 片键一旦选择就不能更改，前期选择片键要谨慎。 11.4. 分片查询 查询的条件是分片片键 路由服务器可以准确找到保存对应数据的分片服务器。 查询的的条件不是分片片键 将请求发送到所有分片服务器上，再将返回的结果整合，整合后返回给客户端。 Zander Hsueh            updated 2022-06-12 18:35:50 "},"Dev/rem布局.html":{"url":"Dev/rem布局.html","title":"rem布局","keywords":"","body":" rem 自适应布局1. rem 基础1.1. 概念1.2. em 与 rem1.3. rem 的优点2. 媒体查询2.1. 概念2.2. 语法规范2.3. 案例——根据屏幕宽度修改背景颜色2.4. 案例——媒体查询 + rem 实现元素动态大小变化2.5. 引入资源3. Less 基础3.1. CSS 的弊端3.2. Less 介绍3.3. 安装 Less3.4. Less 变量3.5. rem 适配方案3.6. 适配方案一3.7. 适配方案二 rem 自适应布局 为什么要使用 rem 布局： 页面布局文字能否随着屏幕大小变化而变化？ 六十布局和 flex 布局主要针对于宽度布局，那高度如何设置？ 怎么样让屏幕发生变化的时候元素高度和宽度等比例缩放？ 1. rem 基础 1.1. 概念 rem （root em）是一个相对单位，类似于 em，em 相对于父元素的字体大小。 不同的是 rem 的基准是相对于 html 元素的字体大小。 1.2. em 与 rem em: Zander div { font-size: 12px; } p { /* 宽和高都是 12px *10 = 120px */ width: 10em; height: 10em; background-color: pink; } rem: html { font-size: 14px; } p { /* 宽和高都是 14px *10 = 140px */ width: 10rem; height: 10rem; background-color: pink; } 1.3. rem 的优点 rem 相对于根元素 html 的文字大小来控制， 便于控制页面中所有使用 rem 单位的元素。——整体控制 2. 媒体查询 2.1. 概念 媒体查询 Midea Query 是 CSS3 新语法，有以下特性： 使用 @media 查询，可以针对不同的媒体类型定义不同的样式 @media 可以针对不同的屏幕尺寸设置不用的样式 当重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面 目前针对很多苹果手机、安卓手机、平板等设备都用得到媒体查询 2.2. 语法规范 @media mediatype and|not|only (media feature) { css-code; } 用 @media 开头 mediatype 指媒体类型，如手机屏幕 关键字 and、not、only media feature 媒体特性，必须有小括号 1. mediatype 媒体类型 将不同的终端设备划分成不同的类型，称为媒体类型。 值 说明 all 用于所有设备 print 用于打印机和打印预览 scree 用于电脑设备、平板电脑、智能手机等 2. 关键字 关键字将媒体类型或多个媒体特性连接到一起作为媒体查询的条件。 and：将多个媒体特性连接到一起，相当于“且” not：排除某个媒体类型，相当于“非” only：指定某个特性的媒体类型 3. 媒体特性 每种媒体类型都具有各自不同的特性，根据不同媒体类型的媒体特性设置不同的展示风格。 值 说明 width 定义输出设备中页面可见区域的宽度 min-width 定义输出设备中最小可见区域宽度 max-width 定义输出设备中最大可见区域宽度 /* 在屏幕上并且最大的宽度是800px时（小于等于800px时）设置的样式 */ @media screen and (max-width: 800px) { body { background-color: pink; } @media screen and (max-width: 500px) { body { background-color: yellow; } } 2.3. 案例——根据屏幕宽度修改背景颜色 /* 1. 媒体查询一般按照从大到小或者从小到大的顺序来设置 */ /* 2. 小于 540 px 时背景颜色为蓝色 */ @media screen and (max-width: 539px) { body { background-color: blue; } } /* 3. 540px～970px时背景颜色为绿色 */ @media screen and (min-width: 540px) and (max-width: 969px) { body { background-color: green; } } /* 4. 大于等于970px背景颜色为红色 */ @media screen and (min-width: 970px){ body { background-color: red; } } 因为 CSS 的层叠性原则，3可省略为： @media screen and (min-width: 540px) { body { background-color: green; } } 媒体查询从小到大写，代码更简洁。 2.4. 案例——媒体查询 + rem 实现元素动态大小变化 Zander * { margin: 0; padding: 0; } @media screen and (min-width: 320px){ html { font-size: 50px; } } @media screen and (min-width: 640px){ html { font-size: 100px; } } .top { height: 1rem; font-size: .5rem; background-color: yellow; color: white; text-align: center; line-height: 1rem; } 购物车 2.5. 引入资源 当样式比较繁多的时候，可针对不同的媒体使用不同的 stylesheets。 原理就是直接在 link 中判断设备的尺寸，然后引用不同的css 文件。 语法规范 3. Less 基础 3.1. CSS 的弊端 CSS 是一门非程序式语言，没有变量、函数、Scope 等概念。 css 需要书写大量看似没有逻辑的代码，冗余度较高 不方便维护及扩展，不利于复用 没有良好的计算能力 3.2. Less 介绍 Leaner Style Sheets 是一门 CSS 扩展语言，也是 CSS 的预处理器。它没有减少 CSS 的功能，而是在现有的 CSS 语法上，为 CSS 加入程序式语言的特性。 如引入了变量、Minxin、运算以及函数等功能，大大简化了 CSS 的编写，并且降低了 CSS 的维护成本，Less 可以让我们用更少的代码做更多的事情。 Less 中文网址：http://lesscss.cn/ 3.3. 安装 Less $ npm install -g less 3.4. Less 变量 变量是指没有固定的值，可以改变的。用于 CSS 中一些常用的颜色和数值定义。 @变量名: 指; 变量命名规范 必须有@为前缀 不能包含特殊符号 不能以数字开头 大小写敏感 less 编译 less 文件需要编译生成为 css 文件，这样 html 页面才能使用。 Vscode Less 插件——Easy Less 插件用来把 less 文件编译为 css 文件。安装完后编写完 less 文件保存文件就会自动转换为 css 文件。 less 嵌套 与 Sass 一致 .nav { .logo { ... } } 内层选择器前没有 & 符号，则它被解析为父选择器后代 如果有 & 符号，被解析为父元素自身或父元素的伪类 a { &:hover { color: yellow; } } less 运算 less 中任何的数字、颜色或者变量都可以参与算术运算。 @border: 5px + 5; div { border: @border solid red; } 运算符中间左右有空格隔开 对于两个不同单位的值之间的运算，运算结果的值取第一个值的单位 如果两个值之间只有一个值有单位，则运算结果取该单位 3.5. rem 适配方案 适配的目标是什么？ 怎么去达成这个目标？ 在实际开发中如何使用？ 1. 方案一 less 媒体查询 rem 2. 方案二 flexible.js rem 3.6. 适配方案一 设计稿常见尺寸宽度： 设备 常见宽度 iphone 5 640px iphone 678 750px Android 常见320px、375px、384px、400px、414px、500px、720px 基本以750px 为准。 @media screen and (min-width: 320px) { html { font-size: 21.33px; } } @media screen and (min-width: 750px) { html { font-size: 50px; } } 动态设置html 标签 font-size 大小： 假设设计稿为750px 把整个屏幕分为 15等份（划分标准不一，也可为10份/20份） 每一份作为html字体大小，这里为50px 那么在320px设备时，字体大小为320px/15=21.33px 元素大小取值方法： 页面元素的 rem 值 = 页面元素值（px）/ （屏幕宽度 / 划分的份数） 屏幕宽度/划分的份数就是 html fon-size 的大小 页面元素rem值 = 页面元素值（px）/ html font-size 字体大小 3.7. 适配方案二 flexible.js： 手机淘宝团队发布的简洁高效移动端适配库。不需要写繁琐的媒体查询，js 里做了相应处理，原理是把当前设备分为10等份，但不同设备下，比例相同。 只需要确定当前设备的 html 文字大小即可，比如当前设计稿为 750px，那么只需要把 html 文字大小设置为 75px（710px /10），页面中元素的 rem 值：页面元素的 px 值 / 75。 下载地址：https://github.com/amfe/lib-flexible Zander Hsueh            updated 2022-06-12 18:35:50 "},"Ops/Docker.html":{"url":"Ops/Docker.html","title":"Docker","keywords":"","body":" Docker1. Docker 简介1.1. Docker 理念1.2. Docker 和虚拟机的区别1.3. Dcoker 基本组成2. Docker 安装2.1. 配置阿里云镜像加速器2.2. Hello World2.3. Docker 底层原理3. Docker 常用命令3.1. 帮助命令3.2. 镜像命令3.3. 容器命令3.4. 其它重要命令4. Docker 镜像4.1. UnionFS4.2. 分层的镜像4.3. 为什么 Docker 要采用分层的结构？4.4. 镜像的特点4.5. Docker 镜像 commit 操作5. Docker 容器数据卷5.1. 在容器内添加数据卷5.2. 数据卷容器6. DockerFile6.1. DockerFile 构建过程解析6.2. DockerFile 保留字指令6.3. 案例7. Docker 常用安装7.1. 安装 mysql7.2. 安装 Nginx8. 本地镜像发布到阿里云8.1. 本地镜像发布到阿里云流程8.2. 镜像的生成方法8.3. 将本地镜像推送到阿里云 Docker 学习链接：Docker 核心技术（基础篇） 1. Docker 简介 一款产品从开发到上线，从操作系统到运行环境，再到应用配置。开发+运维之间的协作需要关心很多东西，这也是不得不面对的问题，特别是各种版本迭代后，不同版本环境的兼容，对运维人员都是考验。 Docker 对此提供了一个标准化的解决方案，不会出现“在我的机器上可以正常工作”的情况。 1.1. Docker 理念 Docker 基于 Go 语言开发，主要目标是 “Build，Ship and Run Any App，Angwhere”，即通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的 APP 及其运行环境能偶做到“一次封装，到处运行”。 Docker 映像即应用： 运行文档 配置环境 运行环境 运行依赖包 操作系统发行版 内核 解决了运行环境和配置问题软件容器，是方便做持续集成并有助于整体发布的虚拟化容器技术。 1.2. Docker 和虚拟机的区别 虚拟机的缺点： 资源占用多 冗余步骤多 启动慢 Docker 使用的是 Linux 容器（Linux Containers）虚拟化技术，它不是一个完整的操作系统，而是对进程进行隔离。有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。容器内只需要软件工作所需的库资源和设置。 传统虚拟机技术虚拟出的是一套硬件，在其上运行一个完整的操作系统，在该系统上再运行所需的应用进程。 Docker 容器内的应用进程直接运行于宿主的内核，容器没有自己的内核，而且也没有进行硬件虚拟，因此更为轻便。 每个容器之间相互隔离，每个容器有自己的文件系统，容器之间进程不会相互影响，能区分计算资源。 1.3. Dcoker 基本组成 镜像（image） 镜像就是一个只读的模板，可以用来创建 Docker 容器，一个景象可以创建很多容器。（类、构造函数的概念） 容器（container） Docker 利用容器独立运行一个或一组应用，容器是用镜像创建的运行实例。 它可以被启动、开始、停止和删除，每个容器都是相互隔离的、保证安全的平台。 可以把容器看作是一个简易版的 Linux 环境（包括 root 用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。 容器和镜像的区别是容器是可读可写的。 仓库（repository） 仓库是集中存放镜像文件的地方，仓库分为公开仓库和私有仓库两种形式，最大的公开仓库是 Docker Hub。 2. Docker 安装 Linux 中查看系统相关信息： $ uname -r Docker 有两个版本： Docker CE 社区版，免费 Docker EE 企业版 centOS8 安装 Docker CE： 添加并启用官方 Docker CE 存储库 $ sudo dnf config-manager --add-repo=https://download.docker.com/linux/centos/docker-ce.repo 列出可用的 docker-ce 软件包 $ dnf list doher-ce --showduplicates | sort -r 跳过损坏依赖包进行安装 $ sudo dnf install docker-ce --nobest 2.1. 配置阿里云镜像加速器 登录阿里云进入容器镜像服务 拿到形如这样的加速器地址： https://qxs22d7v.mirror.aliyuncs.com 配置服务器中 Docker 的配置文件： $ sudo mkdir /etc/docker $ sudo nano /etc/docker/daemon.json 粘贴配置内容： { \"registry-mirrors\": [\"https://qxs22d7v.mirror.aliyuncs.com\"] } 重启 Docker 服务 $ systemctl daemon-reload $ systemctl restart docker 2.2. Hello World 执行 $ docker run hello-world 命令后 Docker 做什么： 在本机寻找该镜像 有则以该镜像为模板生产容器并运行，没有则去 Docker Hub 上查找该镜像 Hub 上能找到则下载到本地，没有则返回错误查不到该镜像 2.3. Docker 底层原理 Docker 是一个 CS 结构系统，守护进程运行在主机上，然后通过 Socket 链接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。容器是一个运行时环境，就是集装箱。 为什么 Docker 比传统虚拟机更快： Docker 有着比虚拟机更少的抽象层，不需要 Hypervisor 实现硬件资源虚拟化，在 CPU、内存利用率上有着明显的优势。 Docker 利用的是宿主机的内核，而不需要 Guest OS。避免了引寻、加载操作系统内核等比较费时费资源的进程。 Docker 容器 虚拟机(VM) 操作系统 与宿主机共享 OS 宿主机 OS 上运行虚拟机 OS 存储大小 镜像小，便于存储与传输 镜像庞大（vmdk、vdi等） 运行性能 几乎无额外性能损失 操作系统额外的 CPU、内存消耗 移植性 轻便、灵活，适应于Linux 笨重，与虚拟化技术耦合度高 硬件亲和性 面向软件开发者 面向硬件运维者 部署速度 快速，秒级 较慢，10s以上 3. Docker 常用命令 3.1. 帮助命令 1. docker version 2. docker info Docker 详细信息。 3. docker --help 3.2. 镜像命令 docker images 列出本地主机上的镜像。 选项 说明 REPOSITORY 仓库镜像源 TAG 镜像标签 IMAGES ID 镜像ID CREATED 创建日期 SIZE 大小 Options： -a：列出本地所有镜像（含中间映像层） -q：只显示镜像 ID --digests：显示镜像的摘要信息 --no-trunc：显示完整的镜像信息 docker search 镜像名 在 Docker Hub 上查找镜像。 Options： -s 数量：只显示 Star 超过该数值的镜像 --no-trunc：显示完整的镜像描述 --automated：只列出 automated build 类型的镜像 docker pull 镜像名 下拉镜像。直接写镜像名默认下拉最新版本的镜像。 docker rmi 镜像名/ID 删除本机上的镜像。 删除多个： $ docker rmi -f 镜像名1:TAG 镜像名2:TAG 删除全部： $ docker rmi -f $(docker -qa) Options： -f：已存在运行的该镜像的容器时强制删除镜像 3.3. 容器命令 新建并启动容器 $ docker run [OPTIONS] IMAGE [COMMAND] [ARG...] OPTIONS： --name=\"容器名字\"：为容器指定一个名字 -d：后台运行容器，并返回容器 ID，即启动守护式容器 -i：以交互模式运行容器，通常与 -t 同时使用 -t：为容器重新分配一个伪输入终端，通常与 -i 同时使用 -P：随即端口映射 -p：指定端口映射，有以下四种形式： ip:hostPort : containerPort ip::containerPort hostPort:containerPort containerPort 例如启动一个 centos 容器： $ docker pull centos $ docker run -it -name=\"zander\" centos 列出当前所有正在运行的容器 $ docker ps [OPTIONS] 默认显示当前正在运行的容器。 OPTIONS: -l：显示上次运行的容器 -a：显示所有当前运行和历史运行的容器 -n 数字：显示最近n个创建的容器 -q：静默模式，只显示容器编号 --no-trunc：显示详细信息 退出容器 退出容器有两种方式： 1. exit 停止并退出容器。 2. ctrl+P+Q 容器不停止退出。 启动容器 $ docker start 容器ID/容器名 重启容器 $ docker restart 容器ID 停止容器 $ docker stop 容器ID 强制停止容器 $ docker kill 容器ID 删除已停止的容器 $ docker rm 容器ID 一次性删除多个容器： $ docker rm -f $(docker ps -a -q) 或 $ docker ps -a -q | xargs docker rm | xargs 意思为将第一个命令的结果作为第二个容器的参数执行之。 3.4. 其它重要命令 启动守护式容器 $ docker run -d 镜像名 指不进入交互模式，并且 docker ps 不显示该的容器。 原因是 Docker 容器后台运行，就必须有一个前台进程。如果容器运行的命令不是那些一直挂起的命令（如运行 top、tail），容器会自动退出。 这是 Docker 的运行机制问题，解决办法是将要运行的程序以前台进程的形式运行。 例子：守护式进程运行 centOS 容器： $ docker run -d centos /bin/sh -c \"while true;do echo hello zander;sleep 2;done\" 然后使用下面的查看容器日志命令可看到打印项，并且使用 docker ps 查看 centos 容器在运行中。 查看容器日志 $ docker logs -f -t --tail 容器ID OPTIONS： -t：加入时间戳 -f：跟随最新的日志打印 --tail 数字：显示最后n条 查看容器内运行的进程 $ docker top 容器ID 查看容器内部细节 $ docker inspect 容器ID 进入容器并进行命令行交互 进入容器内部： $ docker attach 容器ID 在容器外层执行命令，不进入容器交互模式： $ docker exec -t 容器ID command 例：docker exec -t 10bdadad ls -l /tmp 从容器内拷贝文件到主机上 $ docker cp 容器ID: 容器内文件路径 目的主机路径 4. Docker 镜像 镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件。它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。 4.1. UnionFS UnionFS（联合文件系统）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。 UnionFS 是 Docker 镜像的基础，镜像可以通过分层来继承，基于基础镜像（没有父镜像的镜像），可以制作各种具体的应用镜像。 4.2. 分层的镜像 Docker 镜像的最底层是 bootfs（boot file system），主要包含 bootloader 和kernel，前者用于引导加载 kernel，Linux 刚启动时会加载 bootfs。boot 加载完成后整个内核就都在内存中了，此时系统会卸载 bootfs。 在 bootfs 上层的是 rootfs（root file system），包含 Linux 中典型的 /dev，/proc，/bin，/etc 等标准目录和文件。rootfs 就是各种不同操作系统发行版，如 Ubuntu、centOS 等。 分层体现在使用 docker pull 时多个 Pull complete。 4.3. 为什么 Docker 要采用分层的结构？ 最大的好处——共享资源。 比如多个镜像都从相同的 base 镜像构建而来，那么宿主机中只需要保存一份 base 镜像，同时内存中也只需加载一份 base 镜像，就可为所有容器服务。 4.4. 镜像的特点 Docker 镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部，这一层就称为“容器层”，“容器层”之下的都是“镜像层”。 4.5. Docker 镜像 commit 操作 1. docker commit 提交容器副本使得其成为一个新的镜像，提交后可使用 $ docker images 查看。 2. docker commit -m=\"描述信息\" -a=\"作者\" 容器ID 要创建的目标镜像名:[标签名] 5. Docker 容器数据卷 容器运行之后产生的数据需要进行持久化存储，而不是容器停止或删除后数据丢失 容器之间可能共享数据 Docker 中容器数据卷由Docker挂载到容器，不属于联合文件系统，完全独立于容器的生存周期，作用： 数据持久化 容器间继承 + 共享数据 5.1. 在容器内添加数据卷 1. 通过命令添加 $ docker run -it -v /宿主机绝对路径目录:/容器内目录 镜像名 数据卷挂载成功后可通过 $ docker inspect 容器ID 命令查看详细信息，其内有数据卷的相关信息。 目录挂载成功后，容器内文件夹数据的读写可同步共享到宿主机内。 容器停止并退出，主机修改数据后重启容器，数据自动同步。 添加读写保护： $ docker run -it -v /宿主机绝对路径目录:/容器内目录:ro 镜像名 -ro 为 read only，表示容器内只读，而主机可以进行读写。 2. DockerFile 添加 宿主机的根目录下新建文件夹 mydocker 并进入 在 DockerFile 中使用 VOLUME 指令给镜像添加一个或多个数据卷 出于可移植和分享的考虑，不能在 DockerFile 中指定宿主机的目录，因为不能保证所有的宿主机上都存在这样的特定目录。 File 构建 FROM centos VOLUME [\"/dataVolumeContainer1\", \"/dataVolumeContainer2\"] CMD echo \"finished, -------success1\" CMD /bin/bash build 后生成镜像 $ docker build -f /mydocker/DockerFile -t zander/centos . run 容器 $ docker run -it zander/centos 容器内的容器卷已经存在，使用 $ docker inspect 容器id 查看宿主机上的 Volumes 默认绑定的宿主机路径 Dcoker 挂载的主机目录访问出现 cannot open directory .:Permission denied 问题解决办法：在docker run 命令的挂载目录后加 --privileged=true 参数。 5.2. 数据卷容器 命名的容器挂载数据卷，其它容器通过挂载这个（父容器）实现数据共享，挂载数据卷的容器就被称为数据卷容器。 先启动一个父容器 dc01，并在 dataVoluneContainer2 新增内容 $ docker run -it --name=dc01 zander/centos $ cd dataVolumeContainer2 $ touch dc01.txt dc02/dc03 继承自dc01，分别也创建相应的内容 $ docker run -it --name dc02 --volumes-from dc01 zander/centos 此时 dc01/dc02/dc03 的 /dataVolumeContainer2 中有 dc01.txt、dc02.txt/dc03.txt，即成功共享数据 删除容器 dc01 中的 dc01.txt，但容器dc02/dc03 中仍存在 结论：容器之间配置信息的传递，数据卷的生命周期一直持续到没有容器使用它为止（删除互不影响） 6. DockerFile DockerFile 是用来构建 Docker 镜像的构建文件，是由一系列命令和参数构成的脚本。 构建的三个主要步骤： 编写 DockerFile docker build docker run 6.1. DockerFile 构建过程解析 DockerFile 基础知识： 每条保留字指令都必须为大写字母且后面至少要跟随一个参数 指令按照从上到下，顺序执行 # 表示注释 每条指令都会创建一个新的镜像层，并对镜像进行提交 6.2. DockerFile 保留字指令 FROM 基础镜像，当前新镜像是基于哪个镜像的。 MAINTAINER 镜像维护者的姓名和邮箱地址。 RUN 容器构建时需要运行的命令。 EXPOSE 当前容器对外暴露的端口号。 WORKDIR 指定创建运行容器后，终端默认所在的工作路径。 ENV 用来在构建镜像过程中设置环境变量 ADD 将宿主机目录下的文件拷贝进镜像，且 ADD 命令会自动处理 URL 和解压 tar 压缩包。 COPY 类似 ADD，拷贝文件和目录到镜像中。将从构建上下文目录中的文件/目录复制到新的一层镜像内的位置。 VOLUME 容器数据卷，用于数据保存和持久化工作。 CMD 指定一个容器启动时要运行的命令。DockerFile 中可以有多个 CMD 指令，但只有最后一个生效，CMD 会被 docker run 之后的参数替换。 ENTRYPOINT 指定一个容器启动时要运行的命令。目的和 CMD 一样，都是在指定容器启动程序及参数。 docker run 之后的参数会被当作参数传递给 ENTRYPOINT，之后形成新的命令组合。 ONBUILD 当构建一个被继承的 DockerFile 时运行的命令，父镜像在被子继承后父镜像的 onbuild 被触发。 BUILD Both RUN FROM WORKDIR CMD MAINTAINER USER ENV COPY EXPOSE ADD VOLUME RUN ENTRYPOINT ONBUILD .dockerignore 6.3. 案例 docker run 官方 centos 镜像存在的问题： 进入口默认的路径是根目录 默认不支持 vim（因为是精简版centos） 默认不支持 ifconfig，原因同上 自定义 centos 编写 DockerFile FROM centos MAINTAINER zander ENV MYPATH /usr/local WORKDIR $MYPATH RUN yum -y install vim RUN yum -y net-tools EXPOSE 80 CMD echo $MYPATH CMD echo \"success\" CMD /bin/bash 构建镜像 $ docker build -f /mydocker/DockerFile2 -t mycentos:1.0 . 我的 centos 8 在运行时遇到了 Failed to download metadata for repo 'AppStream' 的错误，暂未解决&#x1F641; 运行容器 $ docker run -it mycentos 使用 $ docker history 镜像ID 可查看镜像构建详细步骤 ONBUILD 新建DcokerFile： FROM centos CMD [\"curl\",\"-s\",\"http://www.baidu.cn\"] ONBUILD RUN echo \"father is running-----------------success\" 创建父镜像 $ docker build -f /mydocker/DockerFile3 -t hello_father . 新建DockerFile，继承上方父镜像，构建子镜像 FROM myip_father CMD [\"curl\",\"-s\",\"http://www.baidu.cn\"] $ docker build -f /mydocker/DockerFile4 -t hello_son . 运行此命令时会触发父镜像中的 ONBUILD 项。 7. Docker 常用安装 7.1. 安装 mysql docker search mysql docker pull mysql 运行容器 $ docker run -p 12345:3306 --name zander/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql 7.2. 安装 Nginx [安装 NGINX(https://xuezenghui.com/posts/ecs-server/#%E5%AE%89%E8%A3%85-nginx) 8. 本地镜像发布到阿里云 8.1. 本地镜像发布到阿里云流程 8.2. 镜像的生成方法 DockerFile + docker build 从容器创建一个新的镜像 $ docker commit [OPTIONS] 容器ID [REPOSITORY[:TAG]] 8.3. 将本地镜像推送到阿里云 创建本地镜像 阿里云开发者平台 创建镜像仓库（代码源选择本地仓库） 点击管理按照步骤来 Zander Hsueh            updated 2022-06-12 18:35:50 "}}